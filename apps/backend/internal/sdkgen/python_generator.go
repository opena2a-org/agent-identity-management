package sdkgen

import (
	"archive/zip"
	"bytes"
	"fmt"
	"text/template"
)

// PythonSDKConfig contains configuration for generating Python SDK
type PythonSDKConfig struct {
	AgentID    string
	PublicKey  string
	PrivateKey string
	AIMURL     string
	AgentName  string
	Version    string
}

// GeneratePythonSDK generates a complete Python SDK package with embedded keys
func GeneratePythonSDK(config PythonSDKConfig) ([]byte, error) {
	buf := new(bytes.Buffer)
	zipWriter := zip.NewWriter(buf)

	// Add SDK files
	files := map[string]string{
		"aim_sdk/__init__.py":   pythonInitFile,
		"aim_sdk/client.py":     pythonClientFile,
		"aim_sdk/exceptions.py": pythonExceptionsFile,
		"aim_sdk/config.py":     generatePythonConfig(config),
		"setup.py":              pythonSetupFile,
		"README.md":             generatePythonReadme(config),
		"requirements.txt":      pythonRequirementsFile,
		"example.py":            generatePythonExample(config),
	}

	for filename, content := range files {
		fw, err := zipWriter.Create(filename)
		if err != nil {
			return nil, fmt.Errorf("failed to create %s: %w", filename, err)
		}

		if _, err := fw.Write([]byte(content)); err != nil {
			return nil, fmt.Errorf("failed to write %s: %w", filename, err)
		}
	}

	if err := zipWriter.Close(); err != nil {
		return nil, fmt.Errorf("failed to close zip writer: %w", err)
	}

	return buf.Bytes(), nil
}

// generatePythonConfig generates config.py with embedded credentials
func generatePythonConfig(config PythonSDKConfig) string {
	tmpl := `"""
AIM SDK Configuration - Auto-generated by AIM

⚠️  SECURITY WARNING: This file contains your agent's private key!
    - Never commit this file to version control
    - Never share this file publicly
    - Store securely and use environment variables in production
"""

# Agent credentials (automatically generated by AIM)
AGENT_ID = "{{.AgentID}}"
PUBLIC_KEY = "{{.PublicKey}}"
PRIVATE_KEY = "{{.PrivateKey}}"

# AIM server URL
AIM_URL = "{{.AIMURL}}"

# Agent metadata
AGENT_NAME = "{{.AgentName}}"
SDK_VERSION = "{{.Version}}"
`

	t := template.Must(template.New("config").Parse(tmpl))
	var result bytes.Buffer
	t.Execute(&result, config)
	return result.String()
}

// generatePythonExample generates example.py with usage demonstration
func generatePythonExample(config PythonSDKConfig) string {
	tmpl := `"""
Example usage of AIM SDK for agent: {{.AgentName}}

This example demonstrates automatic identity verification.
"""

from aim_sdk import AIMClient
from aim_sdk.config import AGENT_ID, PUBLIC_KEY, PRIVATE_KEY, AIM_URL

# Initialize AIM client with auto-generated credentials
client = AIMClient(
    agent_id=AGENT_ID,
    public_key=PUBLIC_KEY,
    private_key=PRIVATE_KEY,
    aim_url=AIM_URL
)

# Example 1: Automatic verification with decorator
@client.perform_action("read_database", resource="users_table")
def get_user_data(user_id):
    """
    This function is automatically verified before execution.
    AIM will handle:
    1. Cryptographic signing of the request
    2. Sending verification request to AIM server
    3. Waiting for approval (auto-approved for trusted agents)
    4. Executing the function if approved
    5. Logging the result back to AIM
    """
    # Your agent code here
    print(f"Reading user data for user: {user_id}")
    return {"user_id": user_id, "name": "Alice", "email": "alice@example.com"}


# Example 2: Manual verification for more control
def send_sensitive_email():
    """Example of manual verification with more control"""
    try:
        # Request verification
        verification = client.verify_action(
            action_type="send_email",
            resource="admin@example.com",
            context={
                "subject": "System Alert",
                "priority": "high"
            },
            timeout_seconds=300  # Wait up to 5 minutes for approval
        )

        print(f"✅ Action verified by: {verification['approved_by']}")

        # Perform the action
        print("Sending email...")
        # Your email sending code here

        # Log success
        client.log_action_result(
            verification_id=verification['verification_id'],
            success=True,
            result_summary="Email sent successfully"
        )

    except Exception as e:
        print(f"❌ Action failed: {e}")


if __name__ == "__main__":
    # Example 1: Automatic verification
    print("Example 1: Automatic verification with decorator")
    user_data = get_user_data("12345")
    print(f"Result: {user_data}")

    # Example 2: Manual verification
    print("\nExample 2: Manual verification")
    send_sensitive_email()
`

	t := template.Must(template.New("example").Parse(tmpl))
	var result bytes.Buffer
	t.Execute(&result, config)
	return result.String()
}

// generatePythonReadme generates README.md with setup instructions
func generatePythonReadme(config PythonSDKConfig) string {
	tmpl := `# AIM Python SDK - {{.AgentName}}

Auto-generated SDK for agent identity verification with AIM.

## ⚠️  Security Notice

This SDK package contains your agent's **private key** embedded in ` + "`aim_sdk/config.py`" + `.

**IMPORTANT**:
- 🔒 Never commit this package to version control
- 🔒 Never share this package publicly
- 🔒 Store securely and use environment variables in production
- 🔒 Regenerate keys immediately if compromised

## Quick Start

### 1. Install SDK

` + "```bash" + `
pip install -e .
` + "```" + `

### 2. Run Example

` + "```bash" + `
python example.py
` + "```" + `

### 3. Use in Your Agent

` + "```python" + `
from aim_sdk import AIMClient
from aim_sdk.config import AGENT_ID, PUBLIC_KEY, PRIVATE_KEY, AIM_URL

client = AIMClient(
    agent_id=AGENT_ID,
    public_key=PUBLIC_KEY,
    private_key=PRIVATE_KEY,
    aim_url=AIM_URL
)

@client.perform_action("your_action_type", resource="your_resource")
def your_function():
    # Your agent code here
    pass
` + "```" + `

## Agent Details

- **Agent ID**: ` + "`{{.AgentID}}`" + `
- **Agent Name**: {{.AgentName}}
- **AIM Server**: {{.AIMURL}}
- **SDK Version**: {{.Version}}

## Features

✅ Automatic cryptographic signing (Ed25519)
✅ Seamless identity verification
✅ Decorator-based API (` + "`@perform_action`" + `)
✅ Automatic retry on transient failures
✅ Context manager support
✅ Full type hints

## Documentation

For complete documentation, visit: {{.AIMURL}}/docs

## Support

If you have issues with this SDK:
1. Check the AIM dashboard for agent status
2. Review verification logs in AIM
3. Contact your AIM administrator

---

Generated by AIM (Agent Identity Management)
`

	t := template.Must(template.New("readme").Parse(tmpl))
	var result bytes.Buffer
	t.Execute(&result, config)
	return result.String()
}

// Python SDK file templates (using the actual SDK code we created)
const pythonInitFile = `"""
AIM Python SDK - Automatic Identity Verification for AI Agents
"""

from .client import AIMClient
from .exceptions import AIMError, AuthenticationError, VerificationError, ActionDeniedError

__version__ = "1.0.0"
__all__ = ["AIMClient", "AIMError", "AuthenticationError", "VerificationError", "ActionDeniedError"]
`

const pythonExceptionsFile = `"""
AIM SDK Exception Classes
"""


class AIMError(Exception):
    """Base exception for all AIM SDK errors"""
    pass


class AuthenticationError(AIMError):
    """Raised when authentication with AIM fails"""
    pass


class VerificationError(AIMError):
    """Raised when action verification fails or is rejected"""
    pass


class ActionDeniedError(AIMError):
    """Raised when AIM denies permission to perform an action"""
    pass


class ConfigurationError(AIMError):
    """Raised when SDK is misconfigured"""
    pass
`

const pythonClientFile = `"""
AIM Client - Core SDK functionality for automatic identity verification
"""

import base64
import functools
import json
import time
from typing import Any, Callable, Optional, Dict
from datetime import datetime, timezone

import requests
from nacl.signing import SigningKey
from nacl.encoding import Base64Encoder

from .exceptions import (
    AuthenticationError,
    VerificationError,
    ActionDeniedError,
    ConfigurationError
)


class AIMClient:
    """AIM SDK Client for automatic identity verification."""

    def __init__(
        self,
        agent_id: str,
        public_key: str,
        private_key: str,
        aim_url: str,
        timeout: int = 30,
        auto_retry: bool = True,
        max_retries: int = 3
    ):
        if not agent_id:
            raise ConfigurationError("agent_id is required")
        if not public_key:
            raise ConfigurationError("public_key is required")
        if not private_key:
            raise ConfigurationError("private_key is required")
        if not aim_url:
            raise ConfigurationError("aim_url is required")

        self.agent_id = agent_id
        self.aim_url = aim_url.rstrip('/')
        self.timeout = timeout
        self.auto_retry = auto_retry
        self.max_retries = max_retries

        try:
            private_key_bytes = base64.b64decode(private_key)
            self.signing_key = SigningKey(private_key_bytes)
        except Exception as e:
            raise ConfigurationError(f"Invalid private key format: {e}")

        try:
            expected_public_key = self.signing_key.verify_key.encode(encoder=Base64Encoder).decode('utf-8')
            if expected_public_key != public_key:
                raise ConfigurationError("Public key does not match private key")
        except Exception as e:
            raise ConfigurationError(f"Key validation failed: {e}")

        self.public_key = public_key
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': f'AIM-Python-SDK/1.0.0',
            'Content-Type': 'application/json'
        })

    def _sign_message(self, message: str) -> str:
        message_bytes = message.encode('utf-8')
        signed = self.signing_key.sign(message_bytes)
        signature = signed.signature
        return base64.b64encode(signature).decode('utf-8')

    def _make_request(
        self,
        method: str,
        endpoint: str,
        data: Optional[Dict] = None,
        retry_count: int = 0
    ) -> Dict:
        url = f"{self.aim_url}{endpoint}"

        try:
            response = self.session.request(
                method=method,
                url=url,
                json=data,
                timeout=self.timeout
            )

            if response.status_code == 401:
                raise AuthenticationError("Authentication failed - invalid agent credentials")
            if response.status_code == 403:
                raise AuthenticationError("Forbidden - insufficient permissions")
            if response.status_code >= 500 and self.auto_retry and retry_count < self.max_retries:
                time.sleep(2 ** retry_count)
                return self._make_request(method, endpoint, data, retry_count + 1)

            response.raise_for_status()
            return response.json()

        except requests.exceptions.Timeout:
            if self.auto_retry and retry_count < self.max_retries:
                time.sleep(2 ** retry_count)
                return self._make_request(method, endpoint, data, retry_count + 1)
            raise VerificationError("Request timeout")
        except requests.exceptions.ConnectionError:
            if self.auto_retry and retry_count < self.max_retries:
                time.sleep(2 ** retry_count)
                return self._make_request(method, endpoint, data, retry_count + 1)
            raise VerificationError("Connection failed")
        except requests.exceptions.RequestException as e:
            raise VerificationError(f"Request failed: {e}")

    def verify_action(
        self,
        action_type: str,
        resource: Optional[str] = None,
        context: Optional[Dict[str, Any]] = None,
        timeout_seconds: int = 300
    ) -> Dict:
        timestamp = datetime.now(timezone.utc).isoformat()

        request_payload = {
            "agent_id": self.agent_id,
            "action_type": action_type,
            "resource": resource,
            "context": context or {},
            "timestamp": timestamp
        }

        signature_message = json.dumps(request_payload, sort_keys=True)
        signature = self._sign_message(signature_message)

        request_payload["signature"] = signature
        request_payload["public_key"] = self.public_key

        try:
            result = self._make_request(
                method="POST",
                endpoint="/api/v1/verifications",
                data=request_payload
            )

            verification_id = result.get("id")
            status = result.get("status")

            if status == "approved":
                return {
                    "verified": True,
                    "verification_id": verification_id,
                    "approved_by": result.get("approved_by"),
                    "expires_at": result.get("expires_at")
                }

            if status == "denied":
                reason = result.get("denial_reason", "Action denied by policy")
                raise ActionDeniedError(f"Action denied: {reason}")

            if status == "pending":
                return self._wait_for_approval(verification_id, timeout_seconds)

            raise VerificationError(f"Unexpected verification status: {status}")

        except (AuthenticationError, ActionDeniedError):
            raise
        except Exception as e:
            raise VerificationError(f"Verification request failed: {e}")

    def _wait_for_approval(self, verification_id: str, timeout_seconds: int) -> Dict:
        start_time = time.time()
        poll_interval = 2

        while time.time() - start_time < timeout_seconds:
            try:
                result = self._make_request(
                    method="GET",
                    endpoint=f"/api/v1/verifications/{verification_id}"
                )

                status = result.get("status")

                if status == "approved":
                    return {
                        "verified": True,
                        "verification_id": verification_id,
                        "approved_by": result.get("approved_by"),
                        "expires_at": result.get("expires_at")
                    }

                if status == "denied":
                    reason = result.get("denial_reason", "Action denied")
                    raise ActionDeniedError(f"Action denied: {reason}")

                time.sleep(poll_interval)
                poll_interval = min(poll_interval * 1.5, 10)

            except (AuthenticationError, ActionDeniedError):
                raise
            except Exception:
                time.sleep(poll_interval)

        raise VerificationError(f"Verification timeout after {timeout_seconds} seconds")

    def log_action_result(
        self,
        verification_id: str,
        success: bool,
        result_summary: Optional[str] = None,
        error_message: Optional[str] = None
    ):
        try:
            self._make_request(
                method="POST",
                endpoint=f"/api/v1/verifications/{verification_id}/result",
                data={
                    "success": success,
                    "result_summary": result_summary,
                    "error_message": error_message,
                    "timestamp": datetime.now(timezone.utc).isoformat()
                }
            )
        except Exception:
            pass

    def perform_action(
        self,
        action_type: str,
        resource: Optional[str] = None,
        context: Optional[Dict[str, Any]] = None,
        timeout_seconds: int = 300
    ):
        def decorator(func: Callable) -> Callable:
            @functools.wraps(func)
            def wrapper(*args, **kwargs):
                verification_result = self.verify_action(
                    action_type=action_type,
                    resource=resource,
                    context=context,
                    timeout_seconds=timeout_seconds
                )

                verification_id = verification_result["verification_id"]

                try:
                    result = func(*args, **kwargs)

                    self.log_action_result(
                        verification_id=verification_id,
                        success=True,
                        result_summary=f"Action '{action_type}' completed successfully"
                    )

                    return result

                except Exception as e:
                    self.log_action_result(
                        verification_id=verification_id,
                        success=False,
                        error_message=str(e)
                    )
                    raise

            return wrapper
        return decorator

    def close(self):
        self.session.close()

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()
`

const pythonSetupFile = `from setuptools import setup, find_packages

setup(
    name="aim-sdk",
    version="1.0.0",
    packages=find_packages(),
    install_requires=[
        "requests>=2.28.0",
        "PyNaCl>=1.5.0",
    ],
    python_requires=">=3.8",
)
`

const pythonRequirementsFile = `requests>=2.28.0
PyNaCl>=1.5.0
`
