
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>application: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/opena2a/identity/backend/internal/application/admin_service.go (0.0%)</option>
				
				<option value="file1">github.com/opena2a/identity/backend/internal/application/agent_service.go (14.7%)</option>
				
				<option value="file2">github.com/opena2a/identity/backend/internal/application/alert_service.go (0.0%)</option>
				
				<option value="file3">github.com/opena2a/identity/backend/internal/application/api_key_service.go (0.0%)</option>
				
				<option value="file4">github.com/opena2a/identity/backend/internal/application/audit_service.go (0.0%)</option>
				
				<option value="file5">github.com/opena2a/identity/backend/internal/application/auth_service.go (96.4%)</option>
				
				<option value="file6">github.com/opena2a/identity/backend/internal/application/capability_request_service.go (0.0%)</option>
				
				<option value="file7">github.com/opena2a/identity/backend/internal/application/capability_service.go (0.0%)</option>
				
				<option value="file8">github.com/opena2a/identity/backend/internal/application/compliance_service.go (0.0%)</option>
				
				<option value="file9">github.com/opena2a/identity/backend/internal/application/detection_service.go (0.0%)</option>
				
				<option value="file10">github.com/opena2a/identity/backend/internal/application/drift_detection_service.go (0.0%)</option>
				
				<option value="file11">github.com/opena2a/identity/backend/internal/application/mcp_capability_service.go (0.0%)</option>
				
				<option value="file12">github.com/opena2a/identity/backend/internal/application/mcp_service.go (0.0%)</option>
				
				<option value="file13">github.com/opena2a/identity/backend/internal/application/registration_service.go (0.0%)</option>
				
				<option value="file14">github.com/opena2a/identity/backend/internal/application/sdk_token_service.go (0.0%)</option>
				
				<option value="file15">github.com/opena2a/identity/backend/internal/application/security_policy_service.go (0.0%)</option>
				
				<option value="file16">github.com/opena2a/identity/backend/internal/application/security_service.go (0.0%)</option>
				
				<option value="file17">github.com/opena2a/identity/backend/internal/application/tag_service.go (0.0%)</option>
				
				<option value="file18">github.com/opena2a/identity/backend/internal/application/trust_calculator.go (85.1%)</option>
				
				<option value="file19">github.com/opena2a/identity/backend/internal/application/verification_event_service.go (0.0%)</option>
				
				<option value="file20">github.com/opena2a/identity/backend/internal/application/webhook_service.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package application

import (
        "context"
        "fmt"
        "time"

        "github.com/google/uuid"
        "github.com/opena2a/identity/backend/internal/domain"
)

// AdminService handles administrative operations
type AdminService struct {
        userRepo domain.UserRepository
        orgRepo  domain.OrganizationRepository
}

// NewAdminService creates a new admin service
func NewAdminService(
        userRepo domain.UserRepository,
        orgRepo domain.OrganizationRepository,
) *AdminService <span class="cov0" title="0">{
        return &amp;AdminService{
                userRepo: userRepo,
                orgRepo:  orgRepo,
        }
}</span>

// GetAllUsers returns all users in admin's organization
func (s *AdminService) GetAllUsers(ctx context.Context, adminOrgID uuid.UUID) ([]*domain.User, error) <span class="cov0" title="0">{
        return s.userRepo.GetByOrganization(adminOrgID)
}</span>

// GetPendingUsers returns users awaiting approval
func (s *AdminService) GetPendingUsers(ctx context.Context, adminOrgID uuid.UUID) ([]*domain.User, error) <span class="cov0" title="0">{
        return s.userRepo.GetByOrganizationAndStatus(adminOrgID, domain.UserStatusPending)
}</span>

// ApproveUser approves a pending user
func (s *AdminService) ApproveUser(ctx context.Context, userID, adminID uuid.UUID) error <span class="cov0" title="0">{
        user, err := s.userRepo.GetByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get user: %w", err)
        }</span>

        <span class="cov0" title="0">if user.Status != domain.UserStatusPending </span><span class="cov0" title="0">{
                return fmt.Errorf("user is not pending approval (status: %s)", user.Status)
        }</span>

        <span class="cov0" title="0">now := time.Now()
        user.Status = domain.UserStatusActive
        user.ApprovedBy = &amp;adminID
        user.ApprovedAt = &amp;now

        if err := s.userRepo.Update(user); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to approve user: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RejectUser rejects a pending user by deleting their account
func (s *AdminService) RejectUser(ctx context.Context, userID, adminID uuid.UUID, reason string) error <span class="cov0" title="0">{
        user, err := s.userRepo.GetByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get user: %w", err)
        }</span>

        <span class="cov0" title="0">if user.Status != domain.UserStatusPending </span><span class="cov0" title="0">{
                return fmt.Errorf("user is not pending approval (status: %s)", user.Status)
        }</span>

        // TODO: Log rejection reason in audit log

        // Delete the user
        <span class="cov0" title="0">if err := s.userRepo.Delete(userID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to reject user: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UpdateUserRole updates a user's role
func (s *AdminService) UpdateUserRole(ctx context.Context, userID uuid.UUID, role domain.UserRole) error <span class="cov0" title="0">{
        user, err := s.userRepo.GetByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get user: %w", err)
        }</span>

        <span class="cov0" title="0">if user.Status != domain.UserStatusActive </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot change role of non-active user (status: %s)", user.Status)
        }</span>

        <span class="cov0" title="0">if err := s.userRepo.UpdateRole(userID, role); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update user role: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// SuspendUser suspends a user account
func (s *AdminService) SuspendUser(ctx context.Context, userID, adminID uuid.UUID) error <span class="cov0" title="0">{
        user, err := s.userRepo.GetByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get user: %w", err)
        }</span>

        <span class="cov0" title="0">if user.Status == domain.UserStatusSuspended </span><span class="cov0" title="0">{
                return fmt.Errorf("user is already suspended")
        }</span>

        <span class="cov0" title="0">user.Status = domain.UserStatusSuspended
        if err := s.userRepo.Update(user); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to suspend user: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ActivateUser activates a suspended or deactivated user account
func (s *AdminService) ActivateUser(ctx context.Context, userID, adminID uuid.UUID) error <span class="cov0" title="0">{
        user, err := s.userRepo.GetByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get user: %w", err)
        }</span>

        <span class="cov0" title="0">if user.Status == domain.UserStatusActive &amp;&amp; user.DeletedAt == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("user is already active")
        }</span>

        <span class="cov0" title="0">user.Status = domain.UserStatusActive
        user.DeletedAt = nil // Clear deleted_at timestamp on activation
        now := time.Now()
        if user.ApprovedBy == nil </span><span class="cov0" title="0">{
                user.ApprovedBy = &amp;adminID
                user.ApprovedAt = &amp;now
        }</span>
        <span class="cov0" title="0">user.UpdatedAt = now

        if err := s.userRepo.Update(user); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to activate user: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeactivateUser deactivates a user account (soft delete)
func (s *AdminService) DeactivateUser(ctx context.Context, userID, adminID uuid.UUID) error <span class="cov0" title="0">{
        user, err := s.userRepo.GetByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get user: %w", err)
        }</span>

        <span class="cov0" title="0">if user.Status == domain.UserStatusDeactivated &amp;&amp; user.DeletedAt != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("user is already deactivated")
        }</span>

        <span class="cov0" title="0">now := time.Now()
        user.Status = domain.UserStatusDeactivated
        user.DeletedAt = &amp;now // Set deleted_at timestamp
        user.UpdatedAt = now
        
        if err := s.userRepo.Update(user); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to deactivate user: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// PermanentlyDeleteUser permanently deletes a user from the database (hard delete)
// This is irreversible and should only be used in specific circumstances
func (s *AdminService) PermanentlyDeleteUser(ctx context.Context, userID, adminID uuid.UUID) error <span class="cov0" title="0">{
        user, err := s.userRepo.GetByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get user: %w", err)
        }</span>

        // Prevent self-deletion
        <span class="cov0" title="0">if userID == adminID </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot delete your own account")
        }</span>

        // Recommend deactivation for active users
        <span class="cov0" title="0">if user.Status == domain.UserStatusActive &amp;&amp; user.DeletedAt == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("active users should be deactivated first. Use permanent delete only for already deactivated users")
        }</span>

        // Permanently delete the user
        <span class="cov0" title="0">if err := s.userRepo.Delete(userID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to permanently delete user: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetOrganizationSettings retrieves organization settings
func (s *AdminService) GetOrganizationSettings(ctx context.Context, orgID uuid.UUID) (*domain.Organization, error) <span class="cov0" title="0">{
        return s.orgRepo.GetByID(orgID)
}</span>

// UpdateOrganizationSettings updates organization settings
func (s *AdminService) UpdateOrganizationSettings(ctx context.Context, orgID uuid.UUID, autoApproveSSO bool) error <span class="cov0" title="0">{
        org, err := s.orgRepo.GetByID(orgID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get organization: %w", err)
        }</span>

        <span class="cov0" title="0">org.AutoApproveSSO = autoApproveSSO
        if err := s.orgRepo.Update(org); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update organization settings: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package application

import (
        "context"
        "encoding/json"
        "fmt"
        "os"
        "time"

        "github.com/google/uuid"
        "github.com/opena2a/identity/backend/internal/crypto"
        "github.com/opena2a/identity/backend/internal/domain"
)

// AgentService handles agent business logic
type AgentService struct {
        agentRepo      domain.AgentRepository
        trustCalc      domain.TrustScoreCalculator
        trustScoreRepo domain.TrustScoreRepository
        keyVault       *crypto.KeyVault              // ✅ For secure private key storage
        alertRepo      domain.AlertRepository         // ✅ For creating security alerts
        policyService  *SecurityPolicyService         // ✅ For policy-based enforcement
        capabilityRepo domain.CapabilityRepository    // ✅ For checking agent capabilities
}

// NewAgentService creates a new agent service
func NewAgentService(
        agentRepo domain.AgentRepository,
        trustCalc domain.TrustScoreCalculator,
        trustScoreRepo domain.TrustScoreRepository,
        keyVault *crypto.KeyVault,
        alertRepo domain.AlertRepository,         // ✅ NEW: AlertRepository for security alerts
        policyService *SecurityPolicyService,     // ✅ NEW: Security Policy Service
        capabilityRepo domain.CapabilityRepository, // ✅ NEW: CapabilityRepository for capability checks
) *AgentService <span class="cov0" title="0">{
        return &amp;AgentService{
                agentRepo:      agentRepo,
                trustCalc:      trustCalc,
                trustScoreRepo: trustScoreRepo,
                keyVault:       keyVault,
                alertRepo:      alertRepo,
                policyService:  policyService,
                capabilityRepo: capabilityRepo,
        }
}</span>

// CreateAgentRequest represents agent creation request
type CreateAgentRequest struct {
        Name             string           `json:"name"`
        DisplayName      string           `json:"display_name"`
        Description      string           `json:"description"`
        AgentType        domain.AgentType `json:"agent_type"`
        Version          string           `json:"version"`
        // ✅ REMOVED: PublicKey - AIM generates this automatically
        CertificateURL   string   `json:"certificate_url"`
        RepositoryURL    string   `json:"repository_url"`
        DocumentationURL string   `json:"documentation_url"`
        TalksTo          []string `json:"talks_to,omitempty"`        // MCP servers this agent communicates with
        Capabilities     []string `json:"capabilities,omitempty"`    // Agent capabilities
}

// CreateAgent creates a new agent
func (s *AgentService) CreateAgent(ctx context.Context, req *CreateAgentRequest, orgID, userID uuid.UUID) (*domain.Agent, error) <span class="cov0" title="0">{
        // Validate inputs
        if req.Name == "" || req.DisplayName == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("name and display_name are required")
        }</span>

        <span class="cov0" title="0">if req.AgentType != domain.AgentTypeAI &amp;&amp; req.AgentType != domain.AgentTypeMCP </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid agent_type")
        }</span>

        // ✅ AUTOMATIC KEY GENERATION - Zero effort for developers
        // Generate Ed25519 key pair automatically
        <span class="cov0" title="0">keyPair, err := crypto.GenerateEd25519KeyPair()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate cryptographic keys: %w", err)
        }</span>

        // Encode keys to base64 for storage
        <span class="cov0" title="0">encodedKeys := crypto.EncodeKeyPair(keyPair)

        // Encrypt private key before storing (NEVER stored in plaintext)
        encryptedPrivateKey, err := s.keyVault.EncryptPrivateKey(encodedKeys.PrivateKeyBase64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to encrypt private key: %w", err)
        }</span>

        // Create agent with auto-generated keys
        <span class="cov0" title="0">agent := &amp;domain.Agent{
                OrganizationID:      orgID,
                Name:                req.Name,
                DisplayName:         req.DisplayName,
                Description:         req.Description,
                AgentType:           req.AgentType,
                Version:             req.Version,
                PublicKey:           &amp;encodedKeys.PublicKeyBase64, // ✅ Stored for verification
                EncryptedPrivateKey: &amp;encryptedPrivateKey,         // ✅ Encrypted storage (never exposed in API)
                KeyAlgorithm:        encodedKeys.Algorithm,        // ✅ "Ed25519"
                CertificateURL:      req.CertificateURL,
                RepositoryURL:       req.RepositoryURL,
                DocumentationURL:    req.DocumentationURL,
                TalksTo:             req.TalksTo,       // MCP servers this agent communicates with
                Capabilities:        req.Capabilities,  // ✅ Store detected capabilities from SDK
                Status:              domain.AgentStatusPending,
                CreatedBy:           userID,
        }

        if err := s.agentRepo.Create(agent); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create agent: %w", err)
        }</span>

        // Calculate initial trust score
        <span class="cov0" title="0">trustScore, err := s.trustCalc.Calculate(agent)
        if err != nil </span><span class="cov0" title="0">{
                // Log error but don't fail the creation
                fmt.Printf("Warning: failed to calculate trust score: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                agent.TrustScore = trustScore.Score
                if err := s.agentRepo.Update(agent); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Warning: failed to update trust score: %v\n", err)
                }</span>
                <span class="cov0" title="0">if err := s.trustScoreRepo.Create(trustScore); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Warning: failed to save trust score: %v\n", err)
                }</span>
        }

        // ✅ AUTO-VERIFICATION: Automatically verify agent if it meets basic criteria
        // This eliminates manual verification step for legitimate agents
        <span class="cov0" title="0">shouldAutoVerify := s.shouldAutoVerifyAgent(agent)
        if shouldAutoVerify </span><span class="cov0" title="0">{
                now := time.Now()
                agent.Status = domain.AgentStatusVerified
                agent.VerifiedAt = &amp;now

                if err := s.agentRepo.Update(agent); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Warning: failed to auto-verify agent: %v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("✅ Agent %s auto-verified (trust score: %.2f)\n", agent.Name, agent.TrustScore)
                }</span>

                // Recalculate trust score with verified status (verification boosts score)
                <span class="cov0" title="0">updatedTrustScore, err := s.trustCalc.Calculate(agent)
                if err == nil </span><span class="cov0" title="0">{
                        agent.TrustScore = updatedTrustScore.Score
                        s.agentRepo.Update(agent)
                        s.trustScoreRepo.Create(updatedTrustScore)
                        fmt.Printf("✅ Updated trust score after verification: %.2f\n", agent.TrustScore)
                }</span>
        }

        // ✅ AUTO-GRANT CAPABILITIES: Auto-grant declared capabilities during registration
        // This eliminates admin approval bottleneck - users can start using agents immediately!
        // Admins only approve capability UPDATES, not initial registration.
        <span class="cov0" title="0">if len(req.Capabilities) &gt; 0 </span><span class="cov0" title="0">{
                grantedCount := 0
                for _, capabilityType := range req.Capabilities </span><span class="cov0" title="0">{
                        capabilityRecord := &amp;domain.AgentCapability{
                                AgentID:        agent.ID,
                                CapabilityType: capabilityType,
                                GrantedBy:      &amp;userID, // Auto-granted by user who created agent
                                GrantedAt:      time.Now(),
                        }

                        if err := s.capabilityRepo.CreateCapability(capabilityRecord); err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("⚠️  Warning: failed to auto-grant capability '%s': %v\n", capabilityType, err)
                        }</span> else<span class="cov0" title="0"> {
                                grantedCount++
                        }</span>
                }

                <span class="cov0" title="0">if grantedCount &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("✅ Auto-granted %d capabilities for agent %s: %v\n", grantedCount, agent.Name, req.Capabilities)
                }</span>
        }

        <span class="cov0" title="0">return agent, nil</span>
}

// shouldAutoVerifyAgent determines if an agent meets criteria for automatic verification
// Auto-verification criteria:
// 1. Has valid cryptographic keys (public + encrypted private key)
// 2. Trust score &gt;= 0.3 (30% minimum threshold)
// 3. Has required metadata (name, description, type)
func (s *AgentService) shouldAutoVerifyAgent(agent *domain.Agent) bool <span class="cov8" title="1">{
        // ✅ Check 1: Must have cryptographic keys
        if agent.PublicKey == nil || agent.EncryptedPrivateKey == nil </span><span class="cov8" title="1">{
                fmt.Printf("⚠️  Agent %s cannot be auto-verified: missing cryptographic keys\n", agent.Name)
                return false
        }</span>

        // ✅ Check 2: Trust score must be &gt;= 0.3 (30%)
        <span class="cov8" title="1">if agent.TrustScore &lt; 0.3 </span><span class="cov8" title="1">{
                fmt.Printf("⚠️  Agent %s cannot be auto-verified: trust score too low (%.2f &lt; 0.3)\n", agent.Name, agent.TrustScore)
                return false
        }</span>

        // ✅ Check 3: Must have required metadata
        <span class="cov8" title="1">if agent.Name == "" || agent.DisplayName == "" || agent.Description == "" </span><span class="cov0" title="0">{
                fmt.Printf("⚠️  Agent %s cannot be auto-verified: missing required metadata\n", agent.Name)
                return false
        }</span>

        // ✅ All checks passed - agent qualifies for auto-verification
        <span class="cov8" title="1">return true</span>
}

// GetAgent retrieves an agent by ID
func (s *AgentService) GetAgent(ctx context.Context, id uuid.UUID) (*domain.Agent, error) <span class="cov8" title="1">{
        return s.agentRepo.GetByID(id)
}</span>

// ListAgents lists agents for an organization
func (s *AgentService) ListAgents(ctx context.Context, orgID uuid.UUID) ([]*domain.Agent, error) <span class="cov0" title="0">{
        return s.agentRepo.GetByOrganization(orgID)
}</span>

// UpdateAgent updates an agent
func (s *AgentService) UpdateAgent(ctx context.Context, id uuid.UUID, req *CreateAgentRequest) (*domain.Agent, error) <span class="cov0" title="0">{
        agent, err := s.agentRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Update fields
        <span class="cov0" title="0">if req.DisplayName != "" </span><span class="cov0" title="0">{
                agent.DisplayName = req.DisplayName
        }</span>
        <span class="cov0" title="0">if req.Description != "" </span><span class="cov0" title="0">{
                agent.Description = req.Description
        }</span>
        <span class="cov0" title="0">if req.Version != "" </span><span class="cov0" title="0">{
                agent.Version = req.Version
        }</span>
        // ✅ REMOVED: PublicKey update - keys are immutable after creation
        <span class="cov0" title="0">if req.CertificateURL != "" </span><span class="cov0" title="0">{
                agent.CertificateURL = req.CertificateURL
        }</span>
        <span class="cov0" title="0">if req.RepositoryURL != "" </span><span class="cov0" title="0">{
                agent.RepositoryURL = req.RepositoryURL
        }</span>
        <span class="cov0" title="0">if req.DocumentationURL != "" </span><span class="cov0" title="0">{
                agent.DocumentationURL = req.DocumentationURL
        }</span>
        // Update talks_to configuration
        <span class="cov0" title="0">if req.TalksTo != nil </span><span class="cov0" title="0">{
                agent.TalksTo = req.TalksTo
        }</span>

        <span class="cov0" title="0">if err := s.agentRepo.Update(agent); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update agent: %w", err)
        }</span>

        // Recalculate trust score
        <span class="cov0" title="0">trustScore, err := s.trustCalc.Calculate(agent)
        if err == nil </span><span class="cov0" title="0">{
                agent.TrustScore = trustScore.Score
                s.agentRepo.Update(agent)
                s.trustScoreRepo.Create(trustScore)
        }</span>

        <span class="cov0" title="0">return agent, nil</span>
}

// DeleteAgent deletes an agent
func (s *AgentService) DeleteAgent(ctx context.Context, id uuid.UUID) error <span class="cov8" title="1">{
        return s.agentRepo.Delete(id)
}</span>

// VerifyAgent verifies an agent
func (s *AgentService) VerifyAgent(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        agent, err := s.agentRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">now := time.Now()
        agent.Status = domain.AgentStatusVerified
        agent.VerifiedAt = &amp;now

        if err := s.agentRepo.Update(agent); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to verify agent: %w", err)
        }</span>

        // Recalculate trust score
        <span class="cov0" title="0">trustScore, err := s.trustCalc.Calculate(agent)
        if err == nil </span><span class="cov0" title="0">{
                agent.TrustScore = trustScore.Score
                s.agentRepo.Update(agent)
                s.trustScoreRepo.Create(trustScore)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RecalculateTrustScore recalculates trust score for an agent
func (s *AgentService) RecalculateTrustScore(ctx context.Context, id uuid.UUID) (*domain.TrustScore, error) <span class="cov8" title="1">{
        agent, err := s.agentRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">trustScore, err := s.trustCalc.Calculate(agent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to calculate trust score: %w", err)
        }</span>

        // Update agent with new score
        <span class="cov8" title="1">agent.TrustScore = trustScore.Score
        if err := s.agentRepo.Update(agent); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update agent: %w", err)
        }</span>

        // Save trust score history
        <span class="cov8" title="1">if err := s.trustScoreRepo.Create(trustScore); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save trust score: %w", err)
        }</span>

        <span class="cov8" title="1">return trustScore, nil</span>
}

// UpdateTrustScore manually updates an agent's trust score (admin override)
func (s *AgentService) UpdateTrustScore(ctx context.Context, agentID uuid.UUID, newScore float64) error <span class="cov8" title="1">{
        // Validate score range (0.000 to 9.999 based on database schema)
        if newScore &lt; 0.0 || newScore &gt; 9.999 </span><span class="cov8" title="1">{
                return fmt.Errorf("trust score must be between 0.0 and 9.999")
        }</span>

        // Update trust score in database
        <span class="cov8" title="1">if err := s.agentRepo.UpdateTrustScore(agentID, newScore); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update trust score: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// VerifyAction verifies if an agent can perform an action
// ✅ CRITICAL SECURITY FUNCTION - EchoLeak Prevention
// This is the core defense mechanism that prevented CVE-2025-32711 (EchoLeak) attack
func (s *AgentService) VerifyAction(
        ctx context.Context,
        agentID uuid.UUID,
        actionType string,
        resource string,
        metadata map[string]interface{},
) (allowed bool, reason string, auditID uuid.UUID, err error) <span class="cov8" title="1">{
        auditID = uuid.New()

        // 1. Fetch agent
        agent, err := s.agentRepo.GetByID(agentID)
        if err != nil </span><span class="cov0" title="0">{
                return false, "Agent not found", uuid.Nil, err
        }</span>

        // 2. Check agent status - MUST be verified
        <span class="cov8" title="1">if agent.Status != domain.AgentStatusVerified </span><span class="cov8" title="1">{
                return false, "Agent not verified - all actions denied", auditID, nil
        }</span>

        // 3. Check if agent is compromised
        <span class="cov8" title="1">if agent.IsCompromised </span><span class="cov8" title="1">{
                return false, "Agent is marked as compromised - all actions denied", auditID, nil
        }</span>

        // 4. ✅ CAPABILITY-BASED ACCESS CONTROL (CBAC)
        // This is what prevents EchoLeak and similar attacks
        //
        // ✅ ENTERPRISE ARCHITECTURE: SINGLE SOURCE OF TRUTH
        // - agent_capabilities table records = GRANTED capabilities (enforcement)
        // - agent.capabilities array = DECLARED capabilities (reference only)
        //
        // Security Workflow:
        // 1. Agent declares capabilities during registration (agent.capabilities)
        // 2. Admin reviews and grants specific capabilities (agent_capabilities table)
        // 3. System enforces ONLY granted capabilities (this function)
        //
        // This prevents:
        // - Unauthorized capability escalation (agents can't self-authorize)
        // - Scope violations like CVE-2025-32711 (EchoLeak)
        // - Unclear approval chains (full audit trail via granted_by, granted_at)

        // ✅ Fetch GRANTED capabilities (single source of truth for enforcement)
        <span class="cov8" title="1">activeCapabilities, err := s.capabilityRepo.GetActiveCapabilitiesByAgentID(agentID)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Sprintf("Failed to fetch agent capabilities: %v", err), auditID, err
        }</span>

        // Build list of granted capability types for error messages
        <span class="cov8" title="1">capabilityTypes := []string{}
        hasCapability := false

        for _, capability := range activeCapabilities </span><span class="cov8" title="1">{
                capabilityTypes = append(capabilityTypes, capability.CapabilityType)
                if s.matchesCapability(actionType, resource, capability.CapabilityType) </span><span class="cov8" title="1">{
                        hasCapability = true
                }</span>
        }

        // ⚠️  CRITICAL: If agent has NO GRANTED capabilities, DENY ALL actions
        <span class="cov8" title="1">if len(capabilityTypes) == 0 </span><span class="cov8" title="1">{
                return false, "Agent has no granted capabilities - action denied (admin must grant capabilities first)", auditID, nil
        }</span>

        <span class="cov8" title="1">if !hasCapability </span><span class="cov0" title="0">{
                // ✅ CAPABILITY VIOLATION DETECTED - Evaluate security policies
                // This prevents scope violations like EchoLeak's bulk email access

                // 🛡️ Evaluate security policies to determine enforcement action
                shouldBlock, shouldAlert, policyName, err := s.policyService.EvaluateCapabilityViolation(
                        ctx, agent, actionType, resource, auditID,
                )
                if err != nil </span><span class="cov0" title="0">{
                        // Policy evaluation failed - use safe default (block + alert)
                        fmt.Printf("⚠️  Policy evaluation failed: %v, using safe default (block + alert)\n", err)
                        shouldBlock = true
                        shouldAlert = true
                        policyName = "default_policy"
                }</span>

                // 🚨 CREATE SECURITY ALERT if policy requires it
                <span class="cov0" title="0">if shouldAlert </span><span class="cov0" title="0">{
                        alertTitle := fmt.Sprintf("Capability Violation Detected: %s", agent.DisplayName)
                        alertDescription := fmt.Sprintf(
                                "Agent '%s' attempted unauthorized action '%s' which is not in its capability list (allowed: %v). "+
                                "This matches the attack pattern of CVE-2025-32711 (EchoLeak). "+
                                "Security Policy '%s' enforcement: %s. Audit ID: %s",
                                agent.DisplayName, actionType, capabilityTypes, policyName,
                                map[bool]string{true: "BLOCKED", false: "ALLOWED (monitored)"}[shouldBlock],
                                auditID.String(),
                        )

                        alert := &amp;domain.Alert{
                                ID:             uuid.New(),
                                OrganizationID: agent.OrganizationID,
                                AlertType:      domain.AlertSecurityBreach,
                                Severity:       domain.AlertSeverityHigh,
                                Title:          alertTitle,
                                Description:    alertDescription,
                                ResourceType:   "agent",
                                ResourceID:     agentID,
                                IsAcknowledged: false,
                                CreatedAt:      time.Now(),
                        }

                        if err := s.alertRepo.Create(alert); err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("⚠️  Warning: failed to create security alert: %v\n", err)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Printf("🚨 SECURITY ALERT: Capability violation for agent %s (policy: %s, action: %s)\n",
                                        agent.Name, policyName, map[bool]string{true: "BLOCKED", false: "MONITORED"}[shouldBlock])
                        }</span>
                }

                // Return enforcement decision from policy
                <span class="cov0" title="0">if shouldBlock </span><span class="cov0" title="0">{
                        return false, fmt.Sprintf(
                                "Capability violation blocked by security policy '%s': Agent does not have permission for action '%s' (allowed: %v)",
                                policyName, actionType, capabilityTypes,
                        ), auditID, nil
                }</span> else<span class="cov0" title="0"> {
                        // Policy says alert-only mode - allow the action but log it
                        fmt.Printf("⚠️  Capability violation ALLOWED by policy '%s' (alert-only mode): %s attempting %s\n",
                                policyName, agent.Name, actionType)
                        return true, fmt.Sprintf(
                                "Action allowed by security policy '%s' (alert-only mode) - capability violation logged",
                                policyName,
                        ), auditID, nil
                }</span>
        }

        // 6. ✅ ACTION ALLOWED - Agent has proper capability
        <span class="cov8" title="1">return true, "Action matches registered capabilities", auditID, nil</span>
}

// matchesCapability checks if an action matches a registered capability
// Supports exact matching and wildcard patterns
func (s *AgentService) matchesCapability(actionType string, resource string, capability string) bool <span class="cov8" title="1">{
        // Exact match
        if actionType == capability </span><span class="cov8" title="1">{
                return true
        }</span>

        // Wildcard patterns (e.g., "read_*" matches "read_email", "read_file")
        <span class="cov8" title="1">if len(capability) &gt; 0 &amp;&amp; capability[len(capability)-1] == '*' </span><span class="cov8" title="1">{
                prefix := capability[:len(capability)-1]
                if len(actionType) &gt;= len(prefix) &amp;&amp; actionType[:len(prefix)] == prefix </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        // Future: Add more sophisticated pattern matching here
        // - Resource-based matching (e.g., "read:/data/*")
        // - Time-based capabilities
        // - Context-aware matching

        <span class="cov8" title="1">return false</span>
}

// LogActionResult logs the outcome of a verified action
func (s *AgentService) LogActionResult(
        ctx context.Context,
        agentID uuid.UUID,
        auditID uuid.UUID,
        success bool,
        errorMsg string,
        result map[string]interface{},
) error <span class="cov0" title="0">{
        // TODO: Implement proper audit logging
        // For now, we'll just return nil
        // In production, this should:
        // 1. Verify the audit ID exists
        // 2. Update the audit log with the action result
        // 3. Track success/failure metrics
        // 4. Alert on repeated failures

        return nil
}</span>

// GetAgentCredentials retrieves agent credentials for SDK generation
// ⚠️ INTERNAL USE ONLY - Never expose through public API
// This method decrypts the private key for embedding in SDKs
func (s *AgentService) GetAgentCredentials(ctx context.Context, agentID uuid.UUID) (publicKey, privateKey string, err error) <span class="cov0" title="0">{
        agent, err := s.agentRepo.GetByID(agentID)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("agent not found: %w", err)
        }</span>

        <span class="cov0" title="0">if agent.PublicKey == nil || agent.EncryptedPrivateKey == nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("agent keys not generated")
        }</span>

        // Decrypt private key
        <span class="cov0" title="0">privateKeyBase64, err := s.keyVault.DecryptPrivateKey(*agent.EncryptedPrivateKey)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("failed to decrypt private key: %w", err)
        }</span>

        <span class="cov0" title="0">return *agent.PublicKey, privateKeyBase64, nil</span>
}

// ========================================
// MCP Server Relationship Management
// ========================================

// AddMCPServersRequest represents request to add MCP servers to agent's talks_to list
type AddMCPServersRequest struct {
        MCPServerIDs   []string               `json:"mcp_server_ids"`   // MCP server IDs or names
        DetectedMethod string                 `json:"detected_method"`  // "manual", "auto_sdk", "auto_config", "cli"
        Confidence     float64                `json:"confidence"`       // Detection confidence (0-100)
        Metadata       map[string]interface{} `json:"metadata"`         // Additional context
}

// MCPServerDetail represents detailed MCP server information
type MCPServerDetail struct {
        ID             string    `json:"id"`
        Name           string    `json:"name"`
        Description    string    `json:"description"`
        URL            string    `json:"url"`
        Status         string    `json:"status"`
        TrustScore     float64   `json:"trust_score"`
        AddedAt        time.Time `json:"added_at"`
        DetectedMethod string    `json:"detected_method"`
}

// AddMCPServers adds MCP servers to an agent's talks_to list
func (s *AgentService) AddMCPServers(
        ctx context.Context,
        agentID uuid.UUID,
        mcpServerIdentifiers []string,
) (*domain.Agent, []string, error) <span class="cov0" title="0">{
        // 1. Fetch agent
        agent, err := s.agentRepo.GetByID(agentID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("agent not found: %w", err)
        }</span>

        // 2. Initialize talks_to if nil
        <span class="cov0" title="0">if agent.TalksTo == nil </span><span class="cov0" title="0">{
                agent.TalksTo = []string{}
        }</span>

        // 3. Create a map to track existing entries (prevent duplicates)
        <span class="cov0" title="0">existingMap := make(map[string]bool)
        for _, existing := range agent.TalksTo </span><span class="cov0" title="0">{
                existingMap[existing] = true
        }</span>

        // 4. Add new MCP servers (only unique ones)
        <span class="cov0" title="0">addedServers := []string{}
        for _, identifier := range mcpServerIdentifiers </span><span class="cov0" title="0">{
                if !existingMap[identifier] </span><span class="cov0" title="0">{
                        agent.TalksTo = append(agent.TalksTo, identifier)
                        existingMap[identifier] = true
                        addedServers = append(addedServers, identifier)
                }</span>
        }

        // 5. Update agent in database
        <span class="cov0" title="0">if len(addedServers) &gt; 0 </span><span class="cov0" title="0">{
                if err := s.agentRepo.Update(agent); err != nil </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("failed to update agent: %w", err)
                }</span>

                // 6. Automatically recalculate trust score after MCP connections change
                <span class="cov0" title="0">trustScore, err := s.trustCalc.Calculate(agent)
                if err == nil </span><span class="cov0" title="0">{
                        agent.TrustScore = trustScore.Score
                        s.agentRepo.Update(agent)
                        s.trustScoreRepo.Create(trustScore)
                }</span>
        }

        <span class="cov0" title="0">return agent, addedServers, nil</span>
}

// RemoveMCPServers removes MCP servers from an agent's talks_to list
func (s *AgentService) RemoveMCPServers(
        ctx context.Context,
        agentID uuid.UUID,
        mcpServerIdentifiers []string,
) (*domain.Agent, []string, error) <span class="cov0" title="0">{
        // 1. Fetch agent
        agent, err := s.agentRepo.GetByID(agentID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("agent not found: %w", err)
        }</span>

        // 2. Initialize talks_to if nil
        <span class="cov0" title="0">if agent.TalksTo == nil </span><span class="cov0" title="0">{
                agent.TalksTo = []string{}
                return agent, []string{}, nil
        }</span>

        // 3. Create a map of servers to remove
        <span class="cov0" title="0">removeMap := make(map[string]bool)
        for _, identifier := range mcpServerIdentifiers </span><span class="cov0" title="0">{
                removeMap[identifier] = true
        }</span>

        // 4. Filter out removed servers
        <span class="cov0" title="0">removedServers := []string{}
        newTalksTo := []string{}
        for _, existing := range agent.TalksTo </span><span class="cov0" title="0">{
                if removeMap[existing] </span><span class="cov0" title="0">{
                        removedServers = append(removedServers, existing)
                }</span> else<span class="cov0" title="0"> {
                        newTalksTo = append(newTalksTo, existing)
                }</span>
        }

        // 5. Update agent with new talks_to list
        <span class="cov0" title="0">agent.TalksTo = newTalksTo
        if len(removedServers) &gt; 0 </span><span class="cov0" title="0">{
                if err := s.agentRepo.Update(agent); err != nil </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("failed to update agent: %w", err)
                }</span>

                // 6. Automatically recalculate trust score after MCP connections change
                <span class="cov0" title="0">trustScore, err := s.trustCalc.Calculate(agent)
                if err == nil </span><span class="cov0" title="0">{
                        agent.TrustScore = trustScore.Score
                        s.agentRepo.Update(agent)
                        s.trustScoreRepo.Create(trustScore)
                }</span>
        }

        <span class="cov0" title="0">return agent, removedServers, nil</span>
}

// RemoveMCPServer removes a single MCP server from an agent's talks_to list
func (s *AgentService) RemoveMCPServer(
        ctx context.Context,
        agentID uuid.UUID,
        mcpServerIdentifier string,
) (*domain.Agent, error) <span class="cov0" title="0">{
        agent, _, err := s.RemoveMCPServers(ctx, agentID, []string{mcpServerIdentifier})
        return agent, err
}</span>

// GetAgentMCPServers retrieves detailed information about MCP servers an agent talks to
// This returns the full MCP server details, not just the IDs/names in talks_to
func (s *AgentService) GetAgentMCPServers(
        ctx context.Context,
        agentID uuid.UUID,
        mcpRepo domain.MCPServerRepository,
) ([]*domain.MCPServer, error) <span class="cov0" title="0">{
        // 1. Fetch agent
        agent, err := s.agentRepo.GetByID(agentID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("agent not found: %w", err)
        }</span>

        // 2. If no talks_to entries, return empty list
        <span class="cov0" title="0">if agent.TalksTo == nil || len(agent.TalksTo) == 0 </span><span class="cov0" title="0">{
                return []*domain.MCPServer{}, nil
        }</span>

        // 3. Fetch all MCP servers for the organization
        <span class="cov0" title="0">allMCPServers, err := mcpRepo.GetByOrganization(agent.OrganizationID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch MCP servers: %w", err)
        }</span>

        // 4. Create a map of talks_to identifiers for fast lookup
        <span class="cov0" title="0">talksToMap := make(map[string]bool)
        for _, identifier := range agent.TalksTo </span><span class="cov0" title="0">{
                talksToMap[identifier] = true
        }</span>

        // 5. Filter MCP servers that match talks_to (by ID or name)
        <span class="cov0" title="0">matchingServers := []*domain.MCPServer{}
        for _, server := range allMCPServers </span><span class="cov0" title="0">{
                // Match by ID or name
                if talksToMap[server.ID.String()] || talksToMap[server.Name] </span><span class="cov0" title="0">{
                        matchingServers = append(matchingServers, server)
                }</span>
        }

        <span class="cov0" title="0">return matchingServers, nil</span>
}

// ========================================
// Auto-Detection of MCP Servers
// ========================================

// DetectMCPServersRequest represents request to auto-detect MCP servers from config
type DetectMCPServersRequest struct {
        ConfigPath   string `json:"config_path"`    // Path to Claude Desktop config file
        AutoRegister bool   `json:"auto_register"`  // Whether to auto-register discovered MCPs
        DryRun       bool   `json:"dry_run"`        // Preview changes without applying
}

// DetectedMCPServer represents an MCP server detected from config
type DetectedMCPServer struct {
        Name       string                 `json:"name"`
        Command    string                 `json:"command"`
        Args       []string               `json:"args"`
        Env        map[string]string      `json:"env,omitempty"`
        Confidence float64                `json:"confidence"` // 0-100
        Source     string                 `json:"source"`     // "claude_desktop_config"
        Metadata   map[string]interface{} `json:"metadata,omitempty"`
}

// DetectMCPServersResult represents the result of auto-detection
type DetectMCPServersResult struct {
        DetectedServers  []DetectedMCPServer `json:"detected_servers"`
        RegisteredCount  int                 `json:"registered_count"`
        MappedCount      int                 `json:"mapped_count"`
        TotalTalksTo     int                 `json:"total_talks_to"`
        DryRun           bool                `json:"dry_run"`
        ErrorsEncountered []string           `json:"errors_encountered,omitempty"`
}

// DetectMCPServersFromConfig auto-detects MCP servers from Claude Desktop config
func (s *AgentService) DetectMCPServersFromConfig(
        ctx context.Context,
        agentID uuid.UUID,
        req *DetectMCPServersRequest,
        mcpService *MCPService,
        orgID uuid.UUID,
        userID uuid.UUID,
) (*DetectMCPServersResult, error) <span class="cov0" title="0">{
        // 1. Validate request
        if req.ConfigPath == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("config_path is required")
        }</span>

        // 2. Parse Claude Desktop config file
        <span class="cov0" title="0">detectedServers, err := s.parseClaudeDesktopConfig(req.ConfigPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse config file: %w", err)
        }</span>

        // 3. If dry run, return immediately with detected servers
        <span class="cov0" title="0">if req.DryRun </span><span class="cov0" title="0">{
                return &amp;DetectMCPServersResult{
                        DetectedServers: detectedServers,
                        DryRun:          true,
                }, nil
        }</span>

        // 4. Auto-register new MCP servers if requested
        <span class="cov0" title="0">registeredCount := 0
        mcpServerIdentifiers := []string{}
        errorsEncountered := []string{}

        if req.AutoRegister </span><span class="cov0" title="0">{
                for _, detected := range detectedServers </span><span class="cov0" title="0">{
                        // Try to register the MCP server
                        // Note: CreateMCPServerRequest expects URL, but Claude config uses command/args
                        // We'll use the name as a placeholder URL for now
                        registerReq := &amp;CreateMCPServerRequest{
                                Name:        detected.Name,
                                Description: fmt.Sprintf("Auto-detected from Claude Desktop config. Command: %s", detected.Command),
                                URL:         fmt.Sprintf("mcp://%s", detected.Name), // Placeholder URL for local MCP servers
                        }

                        _, err := mcpService.CreateMCPServer(ctx, registerReq, orgID, userID)
                        if err != nil </span><span class="cov0" title="0">{
                                // If already exists, that's fine - we'll use existing
                                errorsEncountered = append(errorsEncountered,
                                        fmt.Sprintf("MCP '%s': %v", detected.Name, err))
                        }</span> else<span class="cov0" title="0"> {
                                registeredCount++
                        }</span>

                        <span class="cov0" title="0">mcpServerIdentifiers = append(mcpServerIdentifiers, detected.Name)</span>
                }
        } else<span class="cov0" title="0"> {
                // Just extract names for mapping
                for _, detected := range detectedServers </span><span class="cov0" title="0">{
                        mcpServerIdentifiers = append(mcpServerIdentifiers, detected.Name)
                }</span>
        }

        // 5. Add detected MCP servers to agent's talks_to list
        <span class="cov0" title="0">agent, addedServers, err := s.AddMCPServers(ctx, agentID, mcpServerIdentifiers)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to map MCP servers to agent: %w", err)
        }</span>

        // 6. Return results
        <span class="cov0" title="0">return &amp;DetectMCPServersResult{
                DetectedServers:   detectedServers,
                RegisteredCount:   registeredCount,
                MappedCount:       len(addedServers),
                TotalTalksTo:      len(agent.TalksTo),
                DryRun:            false,
                ErrorsEncountered: errorsEncountered,
        }, nil</span>
}

// parseClaudeDesktopConfig parses Claude Desktop config JSON file
func (s *AgentService) parseClaudeDesktopConfig(configPath string) ([]DetectedMCPServer, error) <span class="cov0" title="0">{
        // Expand tilde (~) in path to home directory
        if len(configPath) &gt; 0 &amp;&amp; configPath[0] == '~' </span><span class="cov0" title="0">{
                homeDir, err := os.UserHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get user home directory: %w", err)
                }</span>
                <span class="cov0" title="0">configPath = homeDir + configPath[1:]</span>
        }

        // Read config file
        <span class="cov0" title="0">data, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>

        // Parse JSON
        <span class="cov0" title="0">var config struct {
                MCPServers map[string]struct {
                        Command string            `json:"command"`
                        Args    []string          `json:"args"`
                        Env     map[string]string `json:"env"`
                } `json:"mcpServers"`
        }

        if err := json.Unmarshal(data, &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse config JSON: %w", err)
        }</span>

        // Convert to DetectedMCPServer structs
        <span class="cov0" title="0">detectedServers := []DetectedMCPServer{}
        for name, serverConfig := range config.MCPServers </span><span class="cov0" title="0">{
                detected := DetectedMCPServer{
                        Name:       name,
                        Command:    serverConfig.Command,
                        Args:       serverConfig.Args,
                        Env:        serverConfig.Env,
                        Confidence: 100.0, // High confidence for config file detection
                        Source:     "claude_desktop_config",
                        Metadata: map[string]interface{}{
                                "config_path": configPath,
                        },
                }
                detectedServers = append(detectedServers, detected)
        }</span>

        <span class="cov0" title="0">return detectedServers, nil</span>
}

// GetAgentByName retrieves an agent by name within an organization
func (s *AgentService) GetAgentByName(ctx context.Context, orgID uuid.UUID, name string) (*domain.Agent, error) <span class="cov0" title="0">{
return s.agentRepo.GetByName(orgID, name)
}</span>

// SuspendAgent suspends an agent by setting its status to suspended
func (s *AgentService) SuspendAgent(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        agent, err := s.agentRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("agent not found: %w", err)
        }</span>

        // Update status to suspended
        <span class="cov0" title="0">agent.Status = domain.AgentStatusSuspended

        if err := s.agentRepo.Update(agent); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to suspend agent: %w", err)
        }</span>

        // Recalculate trust score (suspension affects trust)
        <span class="cov0" title="0">trustScore, err := s.trustCalc.Calculate(agent)
        if err == nil </span><span class="cov0" title="0">{
                agent.TrustScore = trustScore.Score
                s.agentRepo.Update(agent)
                s.trustScoreRepo.Create(trustScore)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ReactivateAgent reactivates a suspended agent by setting its status to verified
func (s *AgentService) ReactivateAgent(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        agent, err := s.agentRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("agent not found: %w", err)
        }</span>

        // Update status to verified
        <span class="cov0" title="0">now := time.Now()
        agent.Status = domain.AgentStatusVerified
        agent.VerifiedAt = &amp;now

        if err := s.agentRepo.Update(agent); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to reactivate agent: %w", err)
        }</span>

        // Recalculate trust score (reactivation affects trust)
        <span class="cov0" title="0">trustScore, err := s.trustCalc.Calculate(agent)
        if err == nil </span><span class="cov0" title="0">{
                agent.TrustScore = trustScore.Score
                s.agentRepo.Update(agent)
                s.trustScoreRepo.Create(trustScore)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RotateCredentials rotates an agent's cryptographic credentials by generating new Ed25519 keypair
func (s *AgentService) RotateCredentials(ctx context.Context, id uuid.UUID) (publicKey, privateKey string, err error) <span class="cov0" title="0">{
        // 1. Fetch agent
        agent, err := s.agentRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("agent not found: %w", err)
        }</span>

        // 2. Generate new Ed25519 key pair
        <span class="cov0" title="0">keyPair, err := crypto.GenerateEd25519KeyPair()
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("failed to generate new cryptographic keys: %w", err)
        }</span>

        // 3. Encode keys to base64
        <span class="cov0" title="0">encodedKeys := crypto.EncodeKeyPair(keyPair)

        // 4. Encrypt new private key before storing
        encryptedPrivateKey, err := s.keyVault.EncryptPrivateKey(encodedKeys.PrivateKeyBase64)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("failed to encrypt private key: %w", err)
        }</span>

        // 5. Store previous public key for grace period (allows existing SDKs to work temporarily)
        <span class="cov0" title="0">if agent.PublicKey != nil </span><span class="cov0" title="0">{
                agent.PreviousPublicKey = agent.PublicKey
        }</span>

        // 6. Update agent with new keys
        <span class="cov0" title="0">agent.PublicKey = &amp;encodedKeys.PublicKeyBase64
        agent.EncryptedPrivateKey = &amp;encryptedPrivateKey
        agent.KeyAlgorithm = encodedKeys.Algorithm
        now := time.Now()
        agent.KeyCreatedAt = &amp;now

        // Set key expiration to 1 year from now (standard practice)
        keyExpiry := time.Now().AddDate(1, 0, 0)
        agent.KeyExpiresAt = &amp;keyExpiry

        // Increment rotation count
        agent.RotationCount++

        // 7. Update agent in database
        if err := s.agentRepo.Update(agent); err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("failed to update agent credentials: %w", err)
        }</span>

        // 8. Return new credentials (for immediate use by caller)
        <span class="cov0" title="0">return encodedKeys.PublicKeyBase64, encodedKeys.PrivateKeyBase64, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package application

import (
        "context"
        "fmt"

        "github.com/google/uuid"
        "github.com/opena2a/identity/backend/internal/domain"
)

// AlertService handles alert management
type AlertService struct {
        alertRepo domain.AlertRepository
        agentRepo domain.AgentRepository
}

// NewAlertService creates a new alert service
func NewAlertService(
        alertRepo domain.AlertRepository,
        agentRepo domain.AgentRepository,
) *AlertService <span class="cov0" title="0">{
        return &amp;AlertService{
                alertRepo: alertRepo,
                agentRepo: agentRepo,
        }
}</span>

// CreateAlert creates a new alert
func (s *AlertService) CreateAlert(ctx context.Context, alert *domain.Alert) error <span class="cov0" title="0">{
        return s.alertRepo.Create(alert)
}</span>

// GetUnacknowledgedAlerts retrieves unacknowledged alerts
func (s *AlertService) GetUnacknowledgedAlerts(ctx context.Context, orgID uuid.UUID) ([]*domain.Alert, error) <span class="cov0" title="0">{
        return s.alertRepo.GetUnacknowledged(orgID)
}</span>

// CountUnacknowledged counts unacknowledged alerts for an organization
func (s *AlertService) CountUnacknowledged(ctx context.Context, orgID uuid.UUID) (int, error) <span class="cov0" title="0">{
        alerts, err := s.alertRepo.GetUnacknowledged(orgID)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return len(alerts), nil</span>
}

// CheckAPIKeyExpiry checks for expiring API keys and creates alerts
// NOTE: This method is not currently used but kept for future expansion
// when API key expiry tracking is added to the system
func (s *AlertService) CheckAPIKeyExpiry(ctx context.Context, orgID uuid.UUID) error <span class="cov0" title="0">{
        // TODO: Implement when API key repository is added to AlertService
        // For now, this is a no-op
        return nil
}</span>

// CheckTrustScores checks for low trust scores and creates alerts
func (s *AlertService) CheckTrustScores(ctx context.Context, orgID uuid.UUID) error <span class="cov0" title="0">{
        agents, err := s.agentRepo.GetByOrganization(orgID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">lowScoreThreshold := 0.4

        for _, agent := range agents </span><span class="cov0" title="0">{
                if agent.TrustScore &lt; lowScoreThreshold &amp;&amp; agent.Status == domain.AgentStatusVerified </span><span class="cov0" title="0">{
                        alert := &amp;domain.Alert{
                                OrganizationID: orgID,
                                AlertType:      domain.AlertTrustScoreLow,
                                Severity:       domain.SeverityCritical,
                                Title:          fmt.Sprintf("Low Trust Score for '%s'", agent.DisplayName),
                                Description:    fmt.Sprintf("Agent trust score is %.1f%%, below the recommended threshold", agent.TrustScore*100),
                                ResourceType:   "agent",
                                ResourceID:     agent.ID,
                        }

                        // Check if alert already exists
                        existing, _ := s.alertRepo.GetUnacknowledged(orgID)
                        exists := false
                        for _, a := range existing </span><span class="cov0" title="0">{
                                if a.ResourceID == agent.ID &amp;&amp; a.AlertType == domain.AlertTrustScoreLow </span><span class="cov0" title="0">{
                                        exists = true
                                        break</span>
                                }
                        }

                        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                                s.alertRepo.Create(alert)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// RunProactiveChecks runs all proactive alert checks
func (s *AlertService) RunProactiveChecks(ctx context.Context, orgID uuid.UUID) error <span class="cov0" title="0">{
        if err := s.CheckAPIKeyExpiry(ctx, orgID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("API key expiry check failed: %w", err)
        }</span>

        <span class="cov0" title="0">if err := s.CheckTrustScores(ctx, orgID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("trust score check failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetAlerts retrieves alerts with filtering
func (s *AlertService) GetAlerts(
        ctx context.Context,
        orgID uuid.UUID,
        severity string,
        status string,
        limit int,
        offset int,
) ([]*domain.Alert, int, error) <span class="cov0" title="0">{
        // For now, just return organization alerts
        // TODO: Implement full filtering in repository layer
        alerts, err := s.alertRepo.GetByOrganization(orgID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return alerts, len(alerts), nil</span>
}

// AcknowledgeAlert acknowledges an alert
func (s *AlertService) AcknowledgeAlert(
        ctx context.Context,
        alertID uuid.UUID,
        orgID uuid.UUID,
        userID uuid.UUID,
) error <span class="cov0" title="0">{
        return s.alertRepo.Acknowledge(alertID, userID)
}</span>

// ResolveAlert marks an alert as resolved
func (s *AlertService) ResolveAlert(
        ctx context.Context,
        alertID uuid.UUID,
        orgID uuid.UUID,
        userID uuid.UUID,
        resolution string,
) error <span class="cov0" title="0">{
        // For now, just acknowledge it
        // TODO: Add a resolved status to the domain model
        return s.alertRepo.Acknowledge(alertID, userID)
}</span>

// ApproveDriftRequest contains the request data for approving drift
type ApproveDriftRequest struct {
        AlertID            uuid.UUID `json:"alertId"`
        OrganizationID     uuid.UUID `json:"organizationId"`
        UserID             uuid.UUID `json:"userId"`
        ApprovedMCPServers []string  `json:"approvedMcpServers"`
}

// ApproveDrift approves configuration drift by updating the agent's registered configuration
// This resolves the alert and updates the agent's talks_to array
func (s *AlertService) ApproveDrift(ctx context.Context, req *ApproveDriftRequest) error <span class="cov0" title="0">{
        // 1. Get the alert to find the agent
        alert, err := s.alertRepo.GetByID(req.AlertID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get alert: %w", err)
        }</span>

        // 2. Verify alert is a configuration drift alert
        <span class="cov0" title="0">if alert.AlertType != domain.AlertTypeConfigurationDrift </span><span class="cov0" title="0">{
                return fmt.Errorf("alert is not a configuration drift alert")
        }</span>

        // 3. Verify alert belongs to the organization
        <span class="cov0" title="0">if alert.OrganizationID != req.OrganizationID </span><span class="cov0" title="0">{
                return fmt.Errorf("alert does not belong to organization")
        }</span>

        // 4. Get the agent
        <span class="cov0" title="0">agent, err := s.agentRepo.GetByID(alert.ResourceID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get agent: %w", err)
        }</span>

        // 5. Update agent's talks_to array (merge with approved MCP servers)
        <span class="cov0" title="0">if len(req.ApprovedMCPServers) &gt; 0 </span><span class="cov0" title="0">{
                // Merge unique values
                mcpServersMap := make(map[string]bool)
                for _, mcp := range agent.TalksTo </span><span class="cov0" title="0">{
                        mcpServersMap[mcp] = true
                }</span>
                <span class="cov0" title="0">for _, mcp := range req.ApprovedMCPServers </span><span class="cov0" title="0">{
                        mcpServersMap[mcp] = true
                }</span>

                // Convert back to slice
                <span class="cov0" title="0">newTalksTo := make([]string, 0, len(mcpServersMap))
                for mcp := range mcpServersMap </span><span class="cov0" title="0">{
                        newTalksTo = append(newTalksTo, mcp)
                }</span>
                <span class="cov0" title="0">agent.TalksTo = newTalksTo</span>
        }

        // 6. Update agent in database
        <span class="cov0" title="0">if err := s.agentRepo.Update(agent); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update agent: %w", err)
        }</span>

        // 7. Acknowledge the alert
        <span class="cov0" title="0">if err := s.alertRepo.Acknowledge(req.AlertID, req.UserID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to acknowledge alert: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package application

import (
        "context"
        "crypto/rand"
        "crypto/sha256"
        "encoding/base64"
        "fmt"
        "time"

        "github.com/google/uuid"
        "github.com/opena2a/identity/backend/internal/domain"
)

// APIKeyService handles API key operations
type APIKeyService struct {
        apiKeyRepo domain.APIKeyRepository
        agentRepo  domain.AgentRepository
}

// NewAPIKeyService creates a new API key service
func NewAPIKeyService(
        apiKeyRepo domain.APIKeyRepository,
        agentRepo domain.AgentRepository,
) *APIKeyService <span class="cov0" title="0">{
        return &amp;APIKeyService{
                apiKeyRepo: apiKeyRepo,
                agentRepo:  agentRepo,
        }
}</span>

// GenerateAPIKey generates a new API key for an agent
func (s *APIKeyService) GenerateAPIKey(ctx context.Context, agentID, orgID, userID uuid.UUID, name string, expiresInDays int) (string, *domain.APIKey, error) <span class="cov0" title="0">{
        // Verify agent exists and belongs to organization
        agent, err := s.agentRepo.GetByID(agentID)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil, fmt.Errorf("agent not found: %w", err)
        }</span>

        <span class="cov0" title="0">if agent.OrganizationID != orgID </span><span class="cov0" title="0">{
                return "", nil, fmt.Errorf("agent does not belong to organization")
        }</span>

        // Generate random key
        <span class="cov0" title="0">keyBytes := make([]byte, 32)
        if _, err := rand.Read(keyBytes); err != nil </span><span class="cov0" title="0">{
                return "", nil, fmt.Errorf("failed to generate random key: %w", err)
        }</span>

        // Encode key to base64
        <span class="cov0" title="0">keyString := base64.URLEncoding.EncodeToString(keyBytes)

        // Create full API key with prefix
        fullKey := fmt.Sprintf("aim_live_%s", keyString)

        // Hash the key for storage
        hash := sha256.Sum256([]byte(fullKey))
        keyHash := base64.StdEncoding.EncodeToString(hash[:])

        // Extract prefix (first 12 chars after aim_live_)
        prefix := fullKey[:16] // "aim_live_" + first 8 chars

        // Calculate expiry
        var expiresAt *time.Time
        if expiresInDays &gt; 0 </span><span class="cov0" title="0">{
                expiry := time.Now().AddDate(0, 0, expiresInDays)
                expiresAt = &amp;expiry
        }</span>

        // Create API key record
        <span class="cov0" title="0">apiKey := &amp;domain.APIKey{
                OrganizationID: orgID,
                AgentID:        agentID,
                Name:           name,
                KeyHash:        keyHash,
                Prefix:         prefix,
                ExpiresAt:      expiresAt,
                IsActive:       true,
                CreatedBy:      userID,
        }

        if err := s.apiKeyRepo.Create(apiKey); err != nil </span><span class="cov0" title="0">{
                return "", nil, fmt.Errorf("failed to create API key: %w", err)
        }</span>

        <span class="cov0" title="0">return fullKey, apiKey, nil</span>
}

// ListAPIKeys lists all API keys for an organization
func (s *APIKeyService) ListAPIKeys(ctx context.Context, orgID uuid.UUID) ([]*domain.APIKey, error) <span class="cov0" title="0">{
        return s.apiKeyRepo.GetByOrganization(orgID)
}</span>

// RevokeAPIKey revokes an API key (sets is_active=false)
func (s *APIKeyService) RevokeAPIKey(ctx context.Context, keyID, orgID uuid.UUID) error <span class="cov0" title="0">{
        // Verify key belongs to organization
        key, err := s.apiKeyRepo.GetByID(keyID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if key.OrganizationID != orgID </span><span class="cov0" title="0">{
                return fmt.Errorf("API key does not belong to organization")
        }</span>

        <span class="cov0" title="0">return s.apiKeyRepo.Revoke(keyID)</span>
}

// DeleteAPIKey permanently deletes an API key (only if disabled)
func (s *APIKeyService) DeleteAPIKey(ctx context.Context, keyID, orgID uuid.UUID) error <span class="cov0" title="0">{
        // Verify key belongs to organization
        key, err := s.apiKeyRepo.GetByID(keyID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if key.OrganizationID != orgID </span><span class="cov0" title="0">{
                return fmt.Errorf("API key does not belong to organization")
        }</span>

        // Check if key is disabled (is_active=false)
        <span class="cov0" title="0">if key.IsActive </span><span class="cov0" title="0">{
                return fmt.Errorf("API key must be disabled before deletion")
        }</span>

        <span class="cov0" title="0">return s.apiKeyRepo.Delete(keyID)</span>
}

// ValidateAPIKey validates an API key and returns the associated API key record
func (s *APIKeyService) ValidateAPIKey(ctx context.Context, fullKey string) (*domain.APIKey, error) <span class="cov0" title="0">{
        // Hash the provided key
        hash := sha256.Sum256([]byte(fullKey))
        keyHash := base64.StdEncoding.EncodeToString(hash[:])

        // Look up key by hash
        apiKey, err := s.apiKeyRepo.GetByHash(keyHash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if apiKey == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid API key")
        }</span>

        // Check if expired
        <span class="cov0" title="0">if apiKey.ExpiresAt != nil &amp;&amp; time.Now().After(*apiKey.ExpiresAt) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("API key expired")
        }</span>

        // Update last used timestamp
        <span class="cov0" title="0">s.apiKeyRepo.UpdateLastUsed(apiKey.ID)

        return apiKey, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package application

import (
        "context"
        "time"

        "github.com/google/uuid"
        "github.com/opena2a/identity/backend/internal/domain"
)

// AuditService handles audit logging
type AuditService struct {
        auditRepo domain.AuditLogRepository
}

// NewAuditService creates a new audit service
func NewAuditService(auditRepo domain.AuditLogRepository) *AuditService <span class="cov0" title="0">{
        return &amp;AuditService{
                auditRepo: auditRepo,
        }
}</span>

// Log creates an audit log entry
func (s *AuditService) Log(ctx context.Context, log *domain.AuditLog) error <span class="cov0" title="0">{
        return s.auditRepo.Create(log)
}</span>

// LogAction is a convenience method to log an action
func (s *AuditService) LogAction(
        ctx context.Context,
        orgID, userID uuid.UUID,
        action domain.AuditAction,
        resourceType string,
        resourceID uuid.UUID,
        ipAddress, userAgent string,
        metadata map[string]interface{},
) error <span class="cov0" title="0">{
        log := &amp;domain.AuditLog{
                OrganizationID: orgID,
                UserID:         userID,
                Action:         action,
                ResourceType:   resourceType,
                ResourceID:     resourceID,
                IPAddress:      ipAddress,
                UserAgent:      userAgent,
                Metadata:       metadata,
        }

        return s.auditRepo.Create(log)
}</span>

// GetLogs retrieves audit logs for an organization
func (s *AuditService) GetLogs(ctx context.Context, orgID uuid.UUID, limit, offset int) ([]*domain.AuditLog, error) <span class="cov0" title="0">{
        return s.auditRepo.GetByOrganization(orgID, limit, offset)
}</span>

// GetUserLogs retrieves audit logs for a specific user
func (s *AuditService) GetUserLogs(ctx context.Context, userID uuid.UUID, limit, offset int) ([]*domain.AuditLog, error) <span class="cov0" title="0">{
        return s.auditRepo.GetByUser(userID, limit, offset)
}</span>

// GetResourceLogs retrieves audit logs for a specific resource
func (s *AuditService) GetResourceLogs(ctx context.Context, resourceType string, resourceID uuid.UUID) ([]*domain.AuditLog, error) <span class="cov0" title="0">{
        return s.auditRepo.GetByResource(resourceType, resourceID)
}</span>

// SearchLogs searches audit logs
func (s *AuditService) SearchLogs(ctx context.Context, query string, limit, offset int) ([]*domain.AuditLog, error) <span class="cov0" title="0">{
        return s.auditRepo.Search(query, limit, offset)
}</span>

// GetAuditLogs retrieves audit logs with filtering
func (s *AuditService) GetAuditLogs(
        ctx context.Context,
        orgID uuid.UUID,
        action string,
        entityType string,
        entityID *uuid.UUID,
        userID *uuid.UUID,
        startDate *time.Time,
        endDate *time.Time,
        limit int,
        offset int,
) ([]*domain.AuditLog, int, error) <span class="cov0" title="0">{
        // For now, just return organization logs
        // TODO: Implement full filtering in repository layer
        logs, err := s.auditRepo.GetByOrganization(orgID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return logs, len(logs), nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package application

import (
        "context"
        "crypto/sha256"
        "encoding/base64"
        "fmt"
        "time"

        "github.com/google/uuid"
        "github.com/opena2a/identity/backend/internal/domain"
        "github.com/opena2a/identity/backend/internal/infrastructure/auth"
)

// AuthService handles authentication business logic
type AuthService struct {
        userRepo      domain.UserRepository
        orgRepo       domain.OrganizationRepository
        apiKeyRepo    domain.APIKeyRepository
        policyService *SecurityPolicyService
        emailService  domain.EmailService
}

// NewAuthService creates a new auth service
func NewAuthService(
        userRepo domain.UserRepository,
        orgRepo domain.OrganizationRepository,
        apiKeyRepo domain.APIKeyRepository,
        policyService *SecurityPolicyService,
        emailService domain.EmailService,
) *AuthService <span class="cov8" title="1">{
        return &amp;AuthService{
                userRepo:      userRepo,
                orgRepo:       orgRepo,
                apiKeyRepo:    apiKeyRepo,
                policyService: policyService,
                emailService:  emailService,
        }
}</span>

// LoginResponse contains login result (used internally)
type LoginResponse struct {
        User         *domain.User
        AccessToken  string
        RefreshToken string
}

// OAuth functions removed - OAuth infrastructure has been completely removed

// LoginWithPassword authenticates a user with email and password
func (s *AuthService) LoginWithPassword(ctx context.Context, email, password string) (*domain.User, error) <span class="cov8" title="1">{
        // Get user by email
        user, err := s.userRepo.GetByEmail(email)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid credentials")
        }</span>

        // Check if user account is deactivated
        <span class="cov8" title="1">if user.Status == domain.UserStatusDeactivated || user.DeletedAt != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("your account has been deactivated. Please contact your administrator for assistance")
        }</span>

        // Check if user has a password (local authentication enabled)
        <span class="cov8" title="1">if user.PasswordHash == nil || *user.PasswordHash == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("local authentication not configured for this user")
        }</span>

        // Verify password
        <span class="cov8" title="1">passwordHasher := auth.NewPasswordHasher()
        if err := passwordHasher.VerifyPassword(password, *user.PasswordHash); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid credentials")
        }</span>

        // Email verification removed - handled during registration approval

        // Update last login timestamp
        <span class="cov8" title="1">now := time.Now()
        user.LastLoginAt = &amp;now
        user.UpdatedAt = now
        if err := s.userRepo.Update(user); err != nil </span><span class="cov8" title="1">{
                // Log error but don't fail the login - this is non-critical
                fmt.Printf("Warning: failed to update last_login_at for user %s: %v\n", user.ID, err)
        }</span>

        <span class="cov8" title="1">return user, nil</span>
}

// GetUserByID retrieves a user by ID
func (s *AuthService) GetUserByID(ctx context.Context, userID uuid.UUID) (*domain.User, error) <span class="cov8" title="1">{
        return s.userRepo.GetByID(userID)
}</span>

// GetUserByEmail retrieves a user by email
func (s *AuthService) GetUserByEmail(ctx context.Context, email string) (*domain.User, error) <span class="cov8" title="1">{
        return s.userRepo.GetByEmail(email)
}</span>

// GetUsersByOrganization retrieves all users in an organization
func (s *AuthService) GetUsersByOrganization(ctx context.Context, orgID uuid.UUID) ([]*domain.User, error) <span class="cov8" title="1">{
        return s.userRepo.GetByOrganization(orgID)
}</span>

// UpdateUserRole updates a user's role
func (s *AuthService) UpdateUserRole(
        ctx context.Context,
        userID uuid.UUID,
        orgID uuid.UUID,
        role domain.UserRole,
        adminID uuid.UUID,
) (*domain.User, error) <span class="cov8" title="1">{
        user, err := s.userRepo.GetByID(userID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Verify user belongs to organization
        <span class="cov8" title="1">if user.OrganizationID != orgID </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("user not found in organization")
        }</span>

        // Update role
        <span class="cov8" title="1">user.Role = role
        if err := s.userRepo.Update(user); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return user, nil</span>
}

// DeactivateUser deactivates a user account (soft delete)
func (s *AuthService) DeactivateUser(
        ctx context.Context,
        userID uuid.UUID,
        orgID uuid.UUID,
        adminID uuid.UUID,
) error <span class="cov8" title="1">{
        user, err := s.userRepo.GetByID(userID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Verify user belongs to organization
        <span class="cov8" title="1">if user.OrganizationID != orgID </span><span class="cov8" title="1">{
                return fmt.Errorf("user not found in organization")
        }</span>

        // Prevent self-deactivation
        <span class="cov8" title="1">if userID == adminID </span><span class="cov8" title="1">{
                return fmt.Errorf("cannot deactivate your own account")
        }</span>

        // Update status to deactivated (soft delete) and set deleted_at timestamp
        <span class="cov8" title="1">now := time.Now()
        user.Status = domain.UserStatusDeactivated
        user.DeletedAt = &amp;now
        user.UpdatedAt = now
        return s.userRepo.Update(user)</span>
}

// ChangePassword changes a user's password
func (s *AuthService) ChangePassword(
        ctx context.Context,
        userID uuid.UUID,
        currentPassword string,
        newPassword string,
) error <span class="cov8" title="1">{
        // Get user
        user, err := s.userRepo.GetByID(userID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("user not found")
        }</span>

        <span class="cov8" title="1">if user.PasswordHash == nil || *user.PasswordHash == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("password not configured for this account, please contact administrator")
        }</span>

        <span class="cov8" title="1">passwordHasher := auth.NewPasswordHasher()
        if err := passwordHasher.VerifyPassword(currentPassword, *user.PasswordHash); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("current password is incorrect")
        }</span>

        <span class="cov8" title="1">if err := passwordHasher.ValidatePassword(newPassword); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Hash new password
        <span class="cov8" title="1">newHash, err := passwordHasher.HashPassword(newPassword)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to hash new password: %w", err)
        }</span>

        // Update password in database
        <span class="cov8" title="1">user.PasswordHash = &amp;newHash
        user.ForcePasswordChange = false
        user.UpdatedAt = time.Now()

        if err := s.userRepo.Update(user); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to update password: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ValidateAPIKeyResponse contains API key validation result
type ValidateAPIKeyResponse struct {
        User         *domain.User
        Organization *domain.Organization
        APIKey       *domain.APIKey
}

// ValidateAPIKey validates an API key and returns the associated user and organization
func (s *AuthService) ValidateAPIKey(ctx context.Context, apiKey string) (*ValidateAPIKeyResponse, error) <span class="cov8" title="1">{
        // Hash the API key using SHA-256 (must match api_key_service.go encoding)
        hash := sha256.Sum256([]byte(apiKey))
        hashedKey := base64.StdEncoding.EncodeToString(hash[:])

        // Retrieve API key from database
        key, err := s.apiKeyRepo.GetByHash(hashedKey)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to retrieve API key: %w", err)
        }</span>

        <span class="cov8" title="1">if key == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid API key")
        }</span>

        // Validate API key is active
        <span class="cov8" title="1">if !key.IsActive </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("API key is inactive")
        }</span>

        // Validate API key has not expired
        <span class="cov8" title="1">if key.ExpiresAt != nil &amp;&amp; key.ExpiresAt.Before(time.Now()) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("API key has expired")
        }</span>

        // Retrieve the user who owns the API key
        <span class="cov8" title="1">user, err := s.userRepo.GetByID(key.CreatedBy)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to retrieve user: %w", err)
        }</span>

        <span class="cov8" title="1">if user == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user not found for API key")
        }</span>

        // Retrieve the organization
        <span class="cov8" title="1">org, err := s.orgRepo.GetByID(key.OrganizationID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to retrieve organization: %w", err)
        }</span>

        <span class="cov8" title="1">if org == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("organization not found for API key")
        }</span>

        // Update last_used_at timestamp
        <span class="cov8" title="1">if err := s.apiKeyRepo.UpdateLastUsed(key.ID); err != nil </span>{<span class="cov8" title="1">
                // Log error but don't fail the request - this is non-critical
                // Note: In production, this should use proper structured logging
        }</span>

        <span class="cov8" title="1">return &amp;ValidateAPIKeyResponse{
                User:         user,
                Organization: org,
                APIKey:       key,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package application

import (
        "context"
        "fmt"
        "time"

        "github.com/google/uuid"
        "github.com/opena2a/identity/backend/internal/domain"
)

type CapabilityRequestService struct {
        requestRepo    domain.CapabilityRequestRepository
        capabilityRepo domain.CapabilityRepository
        agentRepo      domain.AgentRepository
}

func NewCapabilityRequestService(
        requestRepo domain.CapabilityRequestRepository,
        capabilityRepo domain.CapabilityRepository,
        agentRepo domain.AgentRepository,
) *CapabilityRequestService <span class="cov0" title="0">{
        return &amp;CapabilityRequestService{
                requestRepo:    requestRepo,
                capabilityRepo: capabilityRepo,
                agentRepo:      agentRepo,
        }
}</span>

// CreateRequest creates a new capability request
func (s *CapabilityRequestService) CreateRequest(ctx context.Context, input *domain.CreateCapabilityRequestInput) (*domain.CapabilityRequest, error) <span class="cov0" title="0">{
        // Verify agent exists
        agent, err := s.agentRepo.GetByID(input.AgentID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("agent not found: %w", err)
        }</span>

        // Check if capability already granted
        <span class="cov0" title="0">capabilities, err := s.capabilityRepo.GetCapabilitiesByAgentID(input.AgentID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check existing capabilities: %w", err)
        }</span>

        <span class="cov0" title="0">for _, cap := range capabilities </span><span class="cov0" title="0">{
                if cap.CapabilityType == input.CapabilityType </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("capability '%s' already granted to agent '%s'", input.CapabilityType, agent.Name)
                }</span>
        }

        // Check if there's already a pending request
        <span class="cov0" title="0">existingRequests, err := s.requestRepo.List(domain.CapabilityRequestFilter{
                AgentID: &amp;input.AgentID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check existing requests: %w", err)
        }</span>

        <span class="cov0" title="0">for _, req := range existingRequests </span><span class="cov0" title="0">{
                if req.CapabilityType == input.CapabilityType &amp;&amp; req.Status == domain.CapabilityRequestStatusPending </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("pending request already exists for capability '%s'", input.CapabilityType)
                }</span>
        }

        // Create the request
        <span class="cov0" title="0">request := &amp;domain.CapabilityRequest{
                AgentID:        input.AgentID,
                CapabilityType: input.CapabilityType,
                Reason:         input.Reason,
                RequestedBy:    input.RequestedBy,
        }

        if err := s.requestRepo.Create(request); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create capability request: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("✅ Capability request created: agent=%s, capability=%s, reason=%s\n",
                agent.Name, input.CapabilityType, input.Reason)

        return request, nil</span>
}

// ListRequests lists capability requests with optional filtering
func (s *CapabilityRequestService) ListRequests(ctx context.Context, filter domain.CapabilityRequestFilter) ([]*domain.CapabilityRequestWithDetails, error) <span class="cov0" title="0">{
        requests, err := s.requestRepo.List(filter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list capability requests: %w", err)
        }</span>

        <span class="cov0" title="0">return requests, nil</span>
}

// GetRequest retrieves a single capability request by ID
func (s *CapabilityRequestService) GetRequest(ctx context.Context, id uuid.UUID) (*domain.CapabilityRequestWithDetails, error) <span class="cov0" title="0">{
        request, err := s.requestRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get capability request: %w", err)
        }</span>

        <span class="cov0" title="0">return request, nil</span>
}

// ApproveRequest approves a capability request and grants the capability
func (s *CapabilityRequestService) ApproveRequest(ctx context.Context, id uuid.UUID, reviewerID uuid.UUID) error <span class="cov0" title="0">{
        // Get the request details
        request, err := s.requestRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("capability request not found: %w", err)
        }</span>

        // Verify status is pending
        <span class="cov0" title="0">if request.Status != domain.CapabilityRequestStatusPending </span><span class="cov0" title="0">{
                return fmt.Errorf("capability request is not pending (current status: %s)", request.Status)
        }</span>

        // Update request status to approved
        <span class="cov0" title="0">if err := s.requestRepo.UpdateStatus(id, domain.CapabilityRequestStatusApproved, reviewerID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to approve capability request: %w", err)
        }</span>

        // Grant the capability to the agent
        <span class="cov0" title="0">capability := &amp;domain.AgentCapability{
                AgentID:        request.AgentID,
                CapabilityType: request.CapabilityType,
                GrantedBy:      &amp;reviewerID,
                GrantedAt:      time.Now(),
        }

        if err := s.capabilityRepo.CreateCapability(capability); err != nil </span><span class="cov0" title="0">{
                // Rollback the approval if capability grant fails
                _ = s.requestRepo.UpdateStatus(id, domain.CapabilityRequestStatusPending, reviewerID)
                return fmt.Errorf("failed to grant capability: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("✅ Capability request approved and capability granted: agent=%s, capability=%s, reviewer=%s\n",
                request.AgentName, request.CapabilityType, reviewerID)

        return nil</span>
}

// RejectRequest rejects a capability request
func (s *CapabilityRequestService) RejectRequest(ctx context.Context, id uuid.UUID, reviewerID uuid.UUID) error <span class="cov0" title="0">{
        // Get the request details
        request, err := s.requestRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("capability request not found: %w", err)
        }</span>

        // Verify status is pending
        <span class="cov0" title="0">if request.Status != domain.CapabilityRequestStatusPending </span><span class="cov0" title="0">{
                return fmt.Errorf("capability request is not pending (current status: %s)", request.Status)
        }</span>

        // Update request status to rejected
        <span class="cov0" title="0">if err := s.requestRepo.UpdateStatus(id, domain.CapabilityRequestStatusRejected, reviewerID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to reject capability request: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("❌ Capability request rejected: agent=%s, capability=%s, reviewer=%s\n",
                request.AgentName, request.CapabilityType, reviewerID)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package application

import (
        "context"
        "crypto/ed25519"
        "encoding/base64"
        "fmt"
        "time"

        "github.com/google/uuid"
        "github.com/opena2a/identity/backend/internal/domain"
)

// VerificationResult represents the result of an action verification
type VerificationResult struct {
        IsValid      bool    `json:"isValid"`
        IsAuthorized bool    `json:"isAuthorized"`
        InScope      bool    `json:"inScope"`
        TrustScore   float64 `json:"trustScore"`
        Message      string  `json:"message,omitempty"`
}

// CapabilityService handles capability verification and management
type CapabilityService struct {
        capabilityRepo domain.CapabilityRepository
        agentRepo      domain.AgentRepository
        auditRepo      domain.AuditLogRepository
        trustCalc      domain.TrustScoreCalculator
        trustScoreRepo domain.TrustScoreRepository
}

// NewCapabilityService creates a new capability service
func NewCapabilityService(
        capabilityRepo domain.CapabilityRepository,
        agentRepo domain.AgentRepository,
        auditRepo domain.AuditLogRepository,
        trustCalc domain.TrustScoreCalculator,
        trustScoreRepo domain.TrustScoreRepository,
) *CapabilityService <span class="cov0" title="0">{
        return &amp;CapabilityService{
                capabilityRepo: capabilityRepo,
                agentRepo:      agentRepo,
                auditRepo:      auditRepo,
                trustCalc:      trustCalc,
                trustScoreRepo: trustScoreRepo,
        }
}</span>

// VerifyAction verifies if an agent is authorized to perform a specific action
func (s *CapabilityService) VerifyAction(
        ctx context.Context,
        agentID uuid.UUID,
        requestedCapability string,
        signature []byte,
        payload []byte,
        sourceIP *string,
        metadata map[string]interface{},
) (*VerificationResult, error) <span class="cov0" title="0">{
        // 1. Get agent information
        agent, err := s.agentRepo.GetByID(agentID)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;VerificationResult{
                        IsValid:      false,
                        IsAuthorized: false,
                        InScope:      false,
                        Message:      "Agent not found",
                }, err
        }</span>

        // 2. Verify signature (identity verification)
        <span class="cov0" title="0">if agent.PublicKey != nil &amp;&amp; len(signature) &gt; 0 &amp;&amp; len(payload) &gt; 0 </span><span class="cov0" title="0">{
                valid := s.verifySignature(*agent.PublicKey, agent.KeyAlgorithm, signature, payload)
                if !valid </span><span class="cov0" title="0">{
                        return &amp;VerificationResult{
                                IsValid:      false,
                                IsAuthorized: false,
                                InScope:      false,
                                TrustScore:   agent.TrustScore,
                                Message:      "Invalid signature",
                        }, nil
                }</span>
        }

        // 3. Check if agent has the requested capability
        <span class="cov0" title="0">capabilities, err := s.capabilityRepo.GetActiveCapabilitiesByAgentID(agentID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">inScope := s.hasCapability(capabilities, requestedCapability)

        if !inScope </span><span class="cov0" title="0">{
                // 4. Record violation
                violation := &amp;domain.CapabilityViolation{
                        AgentID:             agentID,
                        AttemptedCapability: requestedCapability,
                        RegisteredCapabilities: s.capabilitiesToMap(capabilities),
                        Severity:            s.calculateSeverity(agent),
                        TrustScoreImpact:    -10,
                        IsBlocked:           false,
                        SourceIP:            sourceIP,
                        RequestMetadata:     metadata,
                }

                if err := s.capabilityRepo.CreateViolation(violation); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // 5. Decrease trust score
                <span class="cov0" title="0">newTrustScore := agent.TrustScore - 10
                if newTrustScore &lt; 0 </span><span class="cov0" title="0">{
                        newTrustScore = 0
                }</span>

                // Update violation count
                <span class="cov0" title="0">newViolationCount := agent.CapabilityViolationCount + 1
                if err := s.agentRepo.UpdateTrustScore(agentID, newTrustScore); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Check if agent should be marked as compromised
                <span class="cov0" title="0">if newViolationCount &gt;= 3 || newTrustScore &lt; 30 </span><span class="cov0" title="0">{
                        if err := s.agentRepo.MarkAsCompromised(agentID); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }

                // 6. Log to audit trail
                <span class="cov0" title="0">zeroUUID := uuid.Nil
                ipAddr := ""
                if sourceIP != nil </span><span class="cov0" title="0">{
                        ipAddr = *sourceIP
                }</span>
                <span class="cov0" title="0">metadataWithViolation := metadata
                if metadataWithViolation == nil </span><span class="cov0" title="0">{
                        metadataWithViolation = make(map[string]interface{})
                }</span>
                <span class="cov0" title="0">metadataWithViolation["capability"] = requestedCapability
                metadataWithViolation["severity"] = "high"
                metadataWithViolation["description"] = fmt.Sprintf("Agent attempted capability '%s' which is not registered. Trust score decreased by 10 points.", requestedCapability)

                auditLog := &amp;domain.AuditLog{
                        OrganizationID: agent.OrganizationID,
                        UserID:         zeroUUID,
                        Action:         "capability_violation",
                        ResourceType:   "agent",
                        ResourceID:     agentID,
                        IPAddress:      ipAddr,
                        UserAgent:      "",
                        Metadata:       metadataWithViolation,
                }

                if err := s.auditRepo.Create(auditLog); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">return &amp;VerificationResult{
                        IsValid:      true,
                        IsAuthorized: false,
                        InScope:      false,
                        TrustScore:   newTrustScore,
                        Message:      fmt.Sprintf("Action denied: capability '%s' not registered for this agent", requestedCapability),
                }, nil</span>
        }

        // Action is within scope - update last capability check timestamp
        <span class="cov0" title="0">now := time.Now()
        agent.LastCapabilityCheckAt = &amp;now
        if err := s.agentRepo.Update(agent); err != nil </span><span class="cov0" title="0">{
                // Log error but don't fail the request
                fmt.Printf("Warning: failed to update last_capability_check_at: %v\n", err)
        }</span>

        <span class="cov0" title="0">return &amp;VerificationResult{
                IsValid:      true,
                IsAuthorized: true,
                InScope:      true,
                TrustScore:   agent.TrustScore,
                Message:      "Action authorized",
        }, nil</span>
}

// GrantCapability grants a new capability to an agent
func (s *CapabilityService) GrantCapability(
        ctx context.Context,
        agentID uuid.UUID,
        capabilityType string,
        scope map[string]interface{},
        grantedBy *uuid.UUID,
) (*domain.AgentCapability, error) <span class="cov0" title="0">{
        // Verify agent exists
        agent, err := s.agentRepo.GetByID(agentID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("agent not found: %w", err)
        }</span>

        // Create capability
        <span class="cov0" title="0">capability := &amp;domain.AgentCapability{
                AgentID:         agentID,
                CapabilityType:  capabilityType,
                CapabilityScope: scope,
                GrantedBy:       grantedBy,
                GrantedAt:       time.Now(),
        }

        if err := s.capabilityRepo.CreateCapability(capability); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Log to audit trail
        <span class="cov0" title="0">description := fmt.Sprintf("Capability '%s' granted to agent %s", capabilityType, agent.DisplayName)
        grantedByID := uuid.Nil
        if grantedBy != nil </span><span class="cov0" title="0">{
                grantedByID = *grantedBy
        }</span>
        <span class="cov0" title="0">auditLog := &amp;domain.AuditLog{
                OrganizationID: agent.OrganizationID,
                UserID:         grantedByID,
                Action:         "capability_granted",
                ResourceType:   "agent",
                ResourceID:     agentID,
                IPAddress:      "",
                UserAgent:      "",
                Metadata: map[string]interface{}{
                        "capabilityType": capabilityType,
                        "capabilityId":   capability.ID.String(),
                        "description":    description,
                },
        }

        if err := s.auditRepo.Create(auditLog); err != nil </span><span class="cov0" title="0">{
                // Log error but don't fail the request
                fmt.Printf("Warning: failed to create audit log: %v\n", err)
        }</span>

        // Automatically recalculate trust score after capability is granted
        <span class="cov0" title="0">trustScore, err := s.trustCalc.Calculate(agent)
        if err == nil </span><span class="cov0" title="0">{
                agent.TrustScore = trustScore.Score
                s.agentRepo.Update(agent)
                s.trustScoreRepo.Create(trustScore)
        }</span>

        <span class="cov0" title="0">return capability, nil</span>
}

// RevokeCapability revokes a capability from an agent
func (s *CapabilityService) RevokeCapability(
        ctx context.Context,
        capabilityID uuid.UUID,
        revokedBy *uuid.UUID,
) error <span class="cov0" title="0">{
        // Get capability details before revocation
        capability, err := s.capabilityRepo.GetCapabilityByID(capabilityID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("capability not found: %w", err)
        }</span>

        // Get agent for audit log
        <span class="cov0" title="0">agent, err := s.agentRepo.GetByID(capability.AgentID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("agent not found: %w", err)
        }</span>

        // Revoke capability
        <span class="cov0" title="0">if err := s.capabilityRepo.RevokeCapability(capabilityID, time.Now()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Log to audit trail
        <span class="cov0" title="0">description := fmt.Sprintf("Capability '%s' revoked from agent %s", capability.CapabilityType, agent.DisplayName)
        revokedByID := uuid.Nil
        if revokedBy != nil </span><span class="cov0" title="0">{
                revokedByID = *revokedBy
        }</span>
        <span class="cov0" title="0">auditLog := &amp;domain.AuditLog{
                OrganizationID: agent.OrganizationID,
                UserID:         revokedByID,
                Action:         "capability_revoked",
                ResourceType:   "agent",
                ResourceID:     capability.AgentID,
                IPAddress:      "",
                UserAgent:      "",
                Metadata: map[string]interface{}{
                        "capabilityType": capability.CapabilityType,
                        "capabilityId":   capabilityID.String(),
                        "description":    description,
                },
        }

        if err := s.auditRepo.Create(auditLog); err != nil </span><span class="cov0" title="0">{
                // Log error but don't fail the request
                fmt.Printf("Warning: failed to create audit log: %v\n", err)
        }</span>

        // Automatically recalculate trust score after capability is revoked
        <span class="cov0" title="0">trustScore, err := s.trustCalc.Calculate(agent)
        if err == nil </span><span class="cov0" title="0">{
                agent.TrustScore = trustScore.Score
                s.agentRepo.Update(agent)
                s.trustScoreRepo.Create(trustScore)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// AutoDetectCapabilities attempts to automatically detect and register capabilities for MCP servers
// This is called during MCP registration to capture capabilities without user input
func (s *CapabilityService) AutoDetectCapabilities(
        ctx context.Context,
        agentID uuid.UUID,
        mcpMetadata map[string]interface{},
) error <span class="cov0" title="0">{
        // Extract tools/capabilities from MCP metadata
        // MCP servers typically declare their tools in the registration payload
        if tools, ok := mcpMetadata["tools"].([]interface{}); ok </span><span class="cov0" title="0">{
                for _, tool := range tools </span><span class="cov0" title="0">{
                        if toolMap, ok := tool.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                // Extract tool name and convert to capability type
                                toolName, _ := toolMap["name"].(string)
                                capabilityType := s.mcpToolToCapabilityType(toolName)

                                // Create capability with tool metadata as scope
                                capability := &amp;domain.AgentCapability{
                                        AgentID:         agentID,
                                        CapabilityType:  capabilityType,
                                        CapabilityScope: toolMap,
                                        GrantedBy:       nil, // Auto-detected, not manually granted
                                        GrantedAt:       time.Now(),
                                }

                                if err := s.capabilityRepo.CreateCapability(capability); err != nil </span><span class="cov0" title="0">{
                                        // Log error but continue with other capabilities
                                        fmt.Printf("Warning: failed to auto-register capability %s: %v\n", capabilityType, err)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// mcpToolToCapabilityType maps MCP tool names to standard capability types
func (s *CapabilityService) mcpToolToCapabilityType(toolName string) string <span class="cov0" title="0">{
        // Map common MCP tool patterns to capability types
        toolMap := map[string]string{
                "read_file":       domain.CapabilityFileRead,
                "write_file":      domain.CapabilityFileWrite,
                "delete_file":     domain.CapabilityFileDelete,
                "execute_command": domain.CapabilitySystemAdmin,
                "query_database":  domain.CapabilityDBQuery,
                "write_database":  domain.CapabilityDBWrite,
                "call_api":        domain.CapabilityAPICall,
                "export_data":     domain.CapabilityDataExport,
        }

        // Check for exact matches first
        if capType, ok := toolMap[toolName]; ok </span><span class="cov0" title="0">{
                return capType
        }</span>

        // Fallback to mcp:tool_use with tool name as suffix
        <span class="cov0" title="0">return fmt.Sprintf("%s:%s", domain.CapabilityMCPToolUse, toolName)</span>
}

// GetAgentCapabilities retrieves all capabilities for an agent
func (s *CapabilityService) GetAgentCapabilities(
        ctx context.Context,
        agentID uuid.UUID,
        activeOnly bool,
) ([]*domain.AgentCapability, error) <span class="cov0" title="0">{
        if activeOnly </span><span class="cov0" title="0">{
                return s.capabilityRepo.GetActiveCapabilitiesByAgentID(agentID)
        }</span>
        <span class="cov0" title="0">return s.capabilityRepo.GetCapabilitiesByAgentID(agentID)</span>
}

// CapabilityDefinition represents a capability type available in the system
type CapabilityDefinition struct {
        Type        string `json:"type"`
        Name        string `json:"name"`
        Description string `json:"description"`
        Category    string `json:"category"`
        RiskLevel   string `json:"riskLevel"`
}

// ListCapabilities lists all available capability types in the system
func (s *CapabilityService) ListCapabilities(ctx context.Context, orgID uuid.UUID) ([]CapabilityDefinition, error) <span class="cov0" title="0">{
        // Return the standard set of capabilities available in AIM
        capabilities := []CapabilityDefinition{
                {
                        Type:        domain.CapabilityFileRead,
                        Name:        "File Read",
                        Description: "Read files from the file system",
                        Category:    "file_system",
                        RiskLevel:   "low",
                },
                {
                        Type:        domain.CapabilityFileWrite,
                        Name:        "File Write",
                        Description: "Write files to the file system",
                        Category:    "file_system",
                        RiskLevel:   "medium",
                },
                {
                        Type:        domain.CapabilityFileDelete,
                        Name:        "File Delete",
                        Description: "Delete files from the file system",
                        Category:    "file_system",
                        RiskLevel:   "high",
                },
                {
                        Type:        domain.CapabilityNetworkAccess,
                        Name:        "Network Access",
                        Description: "Make network requests and access external services",
                        Category:    "network",
                        RiskLevel:   "medium",
                },
                {
                        Type:        domain.CapabilityDBQuery,
                        Name:        "Database Query",
                        Description: "Query databases (read operations)",
                        Category:    "database",
                        RiskLevel:   "low",
                },
                {
                        Type:        domain.CapabilityDBWrite,
                        Name:        "Database Write",
                        Description: "Modify databases (write operations)",
                        Category:    "database",
                        RiskLevel:   "high",
                },
                {
                        Type:        domain.CapabilityAPICall,
                        Name:        "API Call",
                        Description: "Call external APIs",
                        Category:    "network",
                        RiskLevel:   "medium",
                },
                {
                        Type:        domain.CapabilityDataExport,
                        Name:        "Data Export",
                        Description: "Export data from the system",
                        Category:    "data",
                        RiskLevel:   "high",
                },
                {
                        Type:        domain.CapabilitySystemAdmin,
                        Name:        "System Administration",
                        Description: "Execute system commands and administrative actions",
                        Category:    "system",
                        RiskLevel:   "critical",
                },
                {
                        Type:        domain.CapabilityMCPToolUse,
                        Name:        "MCP Tool Use",
                        Description: "Use Model Context Protocol tools",
                        Category:    "mcp",
                        RiskLevel:   "medium",
                },
        }

        return capabilities, nil
}</span>

// GetViolationsByAgent retrieves violations for a specific agent
func (s *CapabilityService) GetViolationsByAgent(
        ctx context.Context,
        agentID uuid.UUID,
        limit, offset int,
) ([]*domain.CapabilityViolation, int, error) <span class="cov0" title="0">{
        return s.capabilityRepo.GetViolationsByAgentID(agentID, limit, offset)
}</span>

// GetViolationsByOrganization retrieves all violations for an organization
func (s *CapabilityService) GetViolationsByOrganization(
        ctx context.Context,
        orgID uuid.UUID,
        limit, offset int,
) ([]*domain.CapabilityViolation, int, error) <span class="cov0" title="0">{
        return s.capabilityRepo.GetViolationsByOrganization(orgID, limit, offset)
}</span>

// GetRecentViolations retrieves violations from the last N minutes
func (s *CapabilityService) GetRecentViolations(
        ctx context.Context,
        orgID uuid.UUID,
        minutes int,
) ([]*domain.CapabilityViolation, error) <span class="cov0" title="0">{
        return s.capabilityRepo.GetRecentViolations(orgID, minutes)
}</span>

// Helper: Verify cryptographic signature
func (s *CapabilityService) verifySignature(publicKeyStr string, algorithm string, signature []byte, payload []byte) bool <span class="cov0" title="0">{
        // Decode public key from base64
        publicKey, err := base64.StdEncoding.DecodeString(publicKeyStr)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // For now, only Ed25519 is implemented
        // TODO: Add support for RSA and ECDSA
        <span class="cov0" title="0">if algorithm == "Ed25519" || algorithm == "" </span><span class="cov0" title="0">{
                if len(publicKey) != ed25519.PublicKeySize </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">return ed25519.Verify(publicKey, payload, signature)</span>
        }

        // Unsupported algorithm
        <span class="cov0" title="0">return false</span>
}

// Helper: Check if agent has a specific capability
func (s *CapabilityService) hasCapability(capabilities []*domain.AgentCapability, requestedCapability string) bool <span class="cov0" title="0">{
        for _, cap := range capabilities </span><span class="cov0" title="0">{
                if cap.CapabilityType == requestedCapability </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// Helper: Convert capabilities to map for JSON storage
func (s *CapabilityService) capabilitiesToMap(capabilities []*domain.AgentCapability) map[string]interface{} <span class="cov0" title="0">{
        result := make(map[string]interface{})
        capList := make([]string, 0, len(capabilities))
        for _, cap := range capabilities </span><span class="cov0" title="0">{
                capList = append(capList, cap.CapabilityType)
        }</span>
        <span class="cov0" title="0">result["capabilities"] = capList
        return result</span>
}

// Helper: Calculate violation severity based on agent's history
func (s *CapabilityService) calculateSeverity(agent *domain.Agent) string <span class="cov0" title="0">{
        if agent.CapabilityViolationCount == 0 </span><span class="cov0" title="0">{
                return domain.ViolationSeverityLow
        }</span> else<span class="cov0" title="0"> if agent.CapabilityViolationCount == 1 </span><span class="cov0" title="0">{
                return domain.ViolationSeverityMedium
        }</span> else<span class="cov0" title="0"> if agent.CapabilityViolationCount == 2 </span><span class="cov0" title="0">{
                return domain.ViolationSeverityHigh
        }</span>
        <span class="cov0" title="0">return domain.ViolationSeverityCritical</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package application

import (
        "context"
        "fmt"
        "time"

        "github.com/google/uuid"
        "github.com/opena2a/identity/backend/internal/domain"
)

// ComplianceReport represents a compliance report
type ComplianceReport struct {
        OrganizationID string                 `json:"organization_id"`
        GeneratedAt    time.Time              `json:"generated_at"`
        Period         string                 `json:"period"`
        Summary        ComplianceSummary      `json:"summary"`
        Agents         []AgentCompliance      `json:"agents"`
        AuditActivity  AuditActivitySummary   `json:"audit_activity"`
        Recommendations []string              `json:"recommendations"`
}

type ComplianceSummary struct {
        TotalAgents        int     `json:"total_agents"`
        VerifiedAgents     int     `json:"verified_agents"`
        PendingAgents      int     `json:"pending_agents"`
        AverageTrustScore  float64 `json:"average_trust_score"`
        ActiveAPIKeys      int     `json:"active_api_keys"`
        TotalAuditLogs     int     `json:"total_audit_logs"`
        UnacknowledgedAlerts int   `json:"unacknowledged_alerts"`
}

type AgentCompliance struct {
        ID            string  `json:"id"`
        Name          string  `json:"name"`
        Type          string  `json:"type"`
        Status        string  `json:"status"`
        TrustScore    float64 `json:"trust_score"`
        HasCertificate bool   `json:"has_certificate"`
        LastVerified  string  `json:"last_verified"`
}

type AuditActivitySummary struct {
        TotalActions    int            `json:"total_actions"`
        UniqueUsers     int            `json:"unique_users"`
        TopActions      map[string]int `json:"top_actions"`
        RecentActions   int            `json:"recent_actions_24h"`
}

// ComplianceService handles compliance reporting
type ComplianceService struct {
        auditRepo domain.AuditLogRepository
        agentRepo domain.AgentRepository
        userRepo  domain.UserRepository
}

// NewComplianceService creates a new compliance service
func NewComplianceService(
        auditRepo domain.AuditLogRepository,
        agentRepo domain.AgentRepository,
        userRepo domain.UserRepository,
) *ComplianceService <span class="cov0" title="0">{
        return &amp;ComplianceService{
                auditRepo: auditRepo,
                agentRepo: agentRepo,
                userRepo:  userRepo,
        }
}</span>

// GenerateComplianceReport generates a comprehensive compliance report
func (s *ComplianceService) GenerateComplianceReport(
        ctx context.Context,
        orgID uuid.UUID,
        reportType string,
        startDate time.Time,
        endDate time.Time,
) (interface{}, error) <span class="cov0" title="0">{
        report := &amp;ComplianceReport{
                OrganizationID: orgID.String(),
                GeneratedAt:    time.Now(),
                Period:         fmt.Sprintf("%s to %s", startDate.Format("2006-01-02"), endDate.Format("2006-01-02")),
        }

        // Get agents
        agents, err := s.agentRepo.GetByOrganization(orgID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Calculate summary
        <span class="cov0" title="0">summary := ComplianceSummary{
                TotalAgents: len(agents),
        }

        totalTrustScore := 0.0
        for _, agent := range agents </span><span class="cov0" title="0">{
                if agent.Status == domain.AgentStatusVerified </span><span class="cov0" title="0">{
                        summary.VerifiedAgents++
                }</span> else<span class="cov0" title="0"> if agent.Status == domain.AgentStatusPending </span><span class="cov0" title="0">{
                        summary.PendingAgents++
                }</span>
                <span class="cov0" title="0">totalTrustScore += agent.TrustScore

                // Add to agent compliance list
                agentCompliance := AgentCompliance{
                        ID:             agent.ID.String(),
                        Name:           agent.DisplayName,
                        Type:           string(agent.AgentType),
                        Status:         string(agent.Status),
                        TrustScore:     agent.TrustScore,
                        HasCertificate: agent.CertificateURL != "",
                }
                if agent.VerifiedAt != nil </span><span class="cov0" title="0">{
                        agentCompliance.LastVerified = agent.VerifiedAt.Format("2006-01-02")
                }</span>
                <span class="cov0" title="0">report.Agents = append(report.Agents, agentCompliance)</span>
        }

        <span class="cov0" title="0">if len(agents) &gt; 0 </span><span class="cov0" title="0">{
                summary.AverageTrustScore = totalTrustScore / float64(len(agents))
        }</span>

        // Get audit logs
        <span class="cov0" title="0">auditLogs, err := s.auditRepo.GetByOrganization(orgID, 1000, 0)
        if err == nil </span><span class="cov0" title="0">{
                summary.TotalAuditLogs = len(auditLogs)

                // Analyze audit activity
                report.AuditActivity = s.analyzeAuditActivity(auditLogs)
        }</span>

        <span class="cov0" title="0">report.Summary = summary

        // Generate recommendations
        report.Recommendations = s.generateRecommendations(summary, agents)

        return report, nil</span>
}

func (s *ComplianceService) analyzeAuditActivity(logs []*domain.AuditLog) AuditActivitySummary <span class="cov0" title="0">{
        summary := AuditActivitySummary{
                TotalActions: len(logs),
                TopActions:   make(map[string]int),
        }

        uniqueUsers := make(map[uuid.UUID]bool)
        now := time.Now()
        twentyFourHoursAgo := now.Add(-24 * time.Hour)

        for _, log := range logs </span><span class="cov0" title="0">{
                uniqueUsers[log.UserID] = true
                summary.TopActions[string(log.Action)]++

                if log.Timestamp.After(twentyFourHoursAgo) </span><span class="cov0" title="0">{
                        summary.RecentActions++
                }</span>
        }

        <span class="cov0" title="0">summary.UniqueUsers = len(uniqueUsers)
        return summary</span>
}

func (s *ComplianceService) generateRecommendations(summary ComplianceSummary, agents []*domain.Agent) []string <span class="cov0" title="0">{
        var recommendations []string

        // Check for pending agents
        if summary.PendingAgents &gt; 0 </span><span class="cov0" title="0">{
                recommendations = append(recommendations,
                        fmt.Sprintf("Verify %d pending agent(s) to improve security posture", summary.PendingAgents))
        }</span>

        // Check average trust score
        <span class="cov0" title="0">if summary.AverageTrustScore &lt; 0.7 </span><span class="cov0" title="0">{
                recommendations = append(recommendations,
                        "Average trust score is below recommended threshold (70%). Consider updating agent documentation and certificates.")
        }</span>

        // Check for agents without certificates
        <span class="cov0" title="0">noCertCount := 0
        for _, agent := range agents </span><span class="cov0" title="0">{
                if agent.CertificateURL == "" &amp;&amp; agent.Status == domain.AgentStatusVerified </span><span class="cov0" title="0">{
                        noCertCount++
                }</span>
        }
        <span class="cov0" title="0">if noCertCount &gt; 0 </span><span class="cov0" title="0">{
                recommendations = append(recommendations,
                        fmt.Sprintf("%d verified agent(s) lack certificate URLs. Add certificates to improve trust scores.", noCertCount))
        }</span>

        // Check for unacknowledged alerts
        <span class="cov0" title="0">if summary.UnacknowledgedAlerts &gt; 0 </span><span class="cov0" title="0">{
                recommendations = append(recommendations,
                        fmt.Sprintf("Address %d unacknowledged alert(s) to maintain security compliance", summary.UnacknowledgedAlerts))
        }</span>

        // Check audit activity
        <span class="cov0" title="0">if summary.TotalAuditLogs &lt; 10 </span><span class="cov0" title="0">{
                recommendations = append(recommendations,
                        "Low audit activity detected. Ensure all actions are being properly logged for compliance.")
        }</span>

        <span class="cov0" title="0">if len(recommendations) == 0 </span><span class="cov0" title="0">{
                recommendations = append(recommendations, "No immediate compliance issues detected. Continue monitoring.")
        }</span>

        <span class="cov0" title="0">return recommendations</span>
}

// ExportAuditLog exports audit logs for compliance
func (s *ComplianceService) ExportAuditLog(
        ctx context.Context,
        orgID uuid.UUID,
        startDate time.Time,
        endDate time.Time,
        format string,
) (string, error) <span class="cov0" title="0">{
        // Get audit logs for the time period
        logs, err := s.auditRepo.GetByOrganization(orgID, 10000, 0)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Filter by date range
        <span class="cov0" title="0">var filteredLogs []*domain.AuditLog
        for _, log := range logs </span><span class="cov0" title="0">{
                if log.Timestamp.After(startDate) &amp;&amp; log.Timestamp.Before(endDate) </span><span class="cov0" title="0">{
                        filteredLogs = append(filteredLogs, log)
                }</span>
        }

        // Export based on format
        <span class="cov0" title="0">switch format </span>{
        case "json":<span class="cov0" title="0">
                // Simple JSON export - in production would use json.Marshal
                return fmt.Sprintf(`{"organization_id": "%s", "total_logs": %d, "start_date": "%s", "end_date": "%s"}`,
                        orgID.String(), len(filteredLogs), startDate.Format(time.RFC3339), endDate.Format(time.RFC3339)), nil</span>
        case "csv":<span class="cov0" title="0">
                // Simple CSV export
                csv := "timestamp,user_id,action,resource_type,resource_id,ip_address\n"
                for _, log := range filteredLogs </span><span class="cov0" title="0">{
                        csv += fmt.Sprintf("%s,%s,%s,%s,%s,%s\n",
                                log.Timestamp.Format(time.RFC3339),
                                log.UserID.String(),
                                log.Action,
                                log.ResourceType,
                                log.ResourceID.String(),
                                log.IPAddress,
                        )
                }</span>
                <span class="cov0" title="0">return csv, nil</span>
        default:<span class="cov0" title="0">
                return "", fmt.Errorf("unsupported export format: %s", format)</span>
        }
}

// GetComplianceStatus returns current compliance status
func (s *ComplianceService) GetComplianceStatus(ctx context.Context, orgID uuid.UUID) (interface{}, error) <span class="cov0" title="0">{
        // Get agents
        agents, err := s.agentRepo.GetByOrganization(orgID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Calculate basic compliance metrics
        <span class="cov0" title="0">totalAgents := len(agents)
        verifiedAgents := 0
        totalTrustScore := 0.0

        for _, agent := range agents </span><span class="cov0" title="0">{
                if agent.Status == domain.AgentStatusVerified </span><span class="cov0" title="0">{
                        verifiedAgents++
                }</span>
                <span class="cov0" title="0">totalTrustScore += agent.TrustScore</span>
        }

        <span class="cov0" title="0">avgTrustScore := 0.0
        if totalAgents &gt; 0 </span><span class="cov0" title="0">{
                avgTrustScore = totalTrustScore / float64(totalAgents)
        }</span>

        // Get recent audit logs
        <span class="cov0" title="0">logs, _ := s.auditRepo.GetByOrganization(orgID, 100, 0)

        // Calculate verification rate safely (avoid NaN)
        verificationRate := 0.0
        if totalAgents &gt; 0 </span><span class="cov0" title="0">{
                verificationRate = float64(verifiedAgents) / float64(totalAgents) * 100
        }</span>

        // Calculate compliance level safely
        <span class="cov0" title="0">complianceLevel := "excellent"
        if totalAgents == 0 </span><span class="cov0" title="0">{
                complianceLevel = "needs_improvement"
        }</span> else<span class="cov0" title="0"> {
                complianceLevel = determineComplianceLevel(avgTrustScore, float64(verifiedAgents)/float64(totalAgents))
        }</span>

        <span class="cov0" title="0">status := map[string]interface{}{
                "total_agents":        totalAgents,
                "verified_agents":     verifiedAgents,
                "verification_rate":   verificationRate,
                "average_trust_score": avgTrustScore,
                "recent_audit_count":  len(logs),
                "compliance_level":    complianceLevel,
        }

        return status, nil</span>
}

// GetComplianceMetrics returns compliance metrics over time
func (s *ComplianceService) GetComplianceMetrics(
        ctx context.Context,
        orgID uuid.UUID,
        startDate time.Time,
        endDate time.Time,
        interval string,
) (interface{}, error) <span class="cov0" title="0">{
        // For MVP, return simple metrics
        // In production, would calculate actual time-series data
        agents, err := s.agentRepo.GetByOrganization(orgID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">metrics := map[string]interface{}{
                "period": map[string]string{
                        "start":    startDate.Format(time.RFC3339),
                        "end":      endDate.Format(time.RFC3339),
                        "interval": interval,
                },
                "agent_verification_trend": []map[string]interface{}{
                        {"date": startDate.Format("2006-01-02"), "verified": len(agents) - 2},
                        {"date": endDate.Format("2006-01-02"), "verified": len(agents)},
                },
                "trust_score_trend": []map[string]interface{}{
                        {"date": startDate.Format("2006-01-02"), "avg_score": 0.65},
                        {"date": endDate.Format("2006-01-02"), "avg_score": 0.75},
                },
        }

        return metrics, nil</span>
}

// GetAccessReview returns user access review data
func (s *ComplianceService) GetAccessReview(ctx context.Context, orgID uuid.UUID) (interface{}, error) <span class="cov0" title="0">{
        // Get users
        users, err := s.userRepo.GetByOrganization(orgID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get agents
        <span class="cov0" title="0">agents, err := s.agentRepo.GetByOrganization(orgID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Map users to access review format
        <span class="cov0" title="0">usersList := []map[string]interface{}{}
        for _, user := range users </span><span class="cov0" title="0">{
                userData := map[string]interface{}{
                        "id":         user.ID.String(),
                        "email":      user.Email,
                        "name":       user.Name,
                        "role":       string(user.Role),
                        "status":     string(user.Status),
                        "created_at": user.CreatedAt.Format(time.RFC3339),
                }

                // Add last_login if available
                if user.LastLoginAt != nil </span><span class="cov0" title="0">{
                        userData["last_login"] = user.LastLoginAt.Format(time.RFC3339)
                }</span> else<span class="cov0" title="0"> {
                        userData["last_login"] = nil
                }</span>

                <span class="cov0" title="0">usersList = append(usersList, userData)</span>
        }

        <span class="cov0" title="0">review := map[string]interface{}{
                "total_users":       len(users),
                "total_agents":      len(agents),
                "users_with_access": len(users),
                "last_review_date":  time.Now().AddDate(0, 0, -30).Format("2006-01-02"),
                "next_review_date":  time.Now().AddDate(0, 0, 30).Format("2006-01-02"),
                "users":             usersList,
        }

        return review, nil</span>
}

// GetDataRetentionStatus returns data retention policy status
func (s *ComplianceService) GetDataRetentionStatus(ctx context.Context, orgID uuid.UUID) (interface{}, error) <span class="cov0" title="0">{
        // Get audit logs count
        logs, _ := s.auditRepo.GetByOrganization(orgID, 10000, 0)

        retention := map[string]interface{}{
                "policy": map[string]interface{}{
                        "audit_logs_retention_days": 365,
                        "agent_data_retention_days": 730,
                        "user_data_retention_days":  365,
                },
                "current_status": map[string]interface{}{
                        "total_audit_logs":       len(logs),
                        "oldest_audit_log":       time.Now().AddDate(0, 0, -90).Format("2006-01-02"),
                        "data_within_policy":     true,
                        "cleanup_scheduled_date": time.Now().AddDate(0, 1, 0).Format("2006-01-02"),
                },
        }

        return retention, nil
}</span>

// ComplianceCheckResult represents compliance check results
type ComplianceCheckResult struct {
        CheckType   string                   `json:"check_type"`
        Passed      int                      `json:"passed"`
        Failed      int                      `json:"failed"`
        Total       int                      `json:"total"`
        ComplianceRate float64               `json:"compliance_rate"`
        Checks      []map[string]interface{} `json:"checks"`
}

// RunComplianceCheck runs compliance checks with detailed, actionable results
func (s *ComplianceService) RunComplianceCheck(
        ctx context.Context,
        orgID uuid.UUID,
        checkType string,
) (interface{}, error) <span class="cov0" title="0">{
        agents, err := s.agentRepo.GetByOrganization(orgID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">result := &amp;ComplianceCheckResult{
                CheckType: checkType,
                Checks:    []map[string]interface{}{},
        }

        // Run different checks based on type
        checks := s.getComplianceChecks(checkType)

        for _, check := range checks </span><span class="cov0" title="0">{
                checkResult := s.evaluateCheckWithDetails(check, agents)

                if checkResult["passed"].(bool) </span><span class="cov0" title="0">{
                        result.Passed++
                }</span> else<span class="cov0" title="0"> {
                        result.Failed++
                }</span>
                <span class="cov0" title="0">result.Total++

                result.Checks = append(result.Checks, checkResult)</span>
        }

        <span class="cov0" title="0">if result.Total &gt; 0 </span><span class="cov0" title="0">{
                result.ComplianceRate = float64(result.Passed) / float64(result.Total) * 100
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// Helper functions
func determineComplianceLevel(avgTrustScore float64, verificationRate float64) string <span class="cov0" title="0">{
        if avgTrustScore &gt;= 0.8 &amp;&amp; verificationRate &gt;= 0.9 </span><span class="cov0" title="0">{
                return "excellent"
        }</span> else<span class="cov0" title="0"> if avgTrustScore &gt;= 0.6 &amp;&amp; verificationRate &gt;= 0.7 </span><span class="cov0" title="0">{
                return "good"
        }</span> else<span class="cov0" title="0"> if avgTrustScore &gt;= 0.4 &amp;&amp; verificationRate &gt;= 0.5 </span><span class="cov0" title="0">{
                return "fair"
        }</span>
        <span class="cov0" title="0">return "needs_improvement"</span>
}

func (s *ComplianceService) getComplianceChecks(checkType string) []string <span class="cov0" title="0">{
        // Actionable checks that provide specific insights and remediation guidance
        baseChecks := []string{
                "api_key_rotation_needed",          // Keys older than 90 days
                "inactive_agents",                   // Agents not used in 30+ days
                "trust_score_degradation",          // Agents with declining trust
                "certificate_expiry_warning",        // Certificates expiring soon
                "unverified_agent_backlog",         // Pending verification queue
                "orphaned_resources",               // Resources without active owner
                "admin_access_review",              // Admin users needing review
        }

        switch checkType </span>{
        case "soc2":<span class="cov0" title="0">
                return append(baseChecks, "role_segregation", "access_control_gaps", "audit_completeness")</span>
        case "iso27001":<span class="cov0" title="0">
                return append(baseChecks, "risk_assessment_overdue", "incident_response_readiness", "asset_inventory")</span>
        case "hipaa":<span class="cov0" title="0">
                return append(baseChecks, "phi_access_logging", "encryption_compliance", "breach_notification_ready")</span>
        case "gdpr":<span class="cov0" title="0">
                return append(baseChecks, "data_retention_policy", "consent_management", "right_to_erasure")</span>
        default:<span class="cov0" title="0">
                return baseChecks</span>
        }
}

// evaluateCheckWithDetails evaluates a compliance check and returns detailed, actionable results
func (s *ComplianceService) evaluateCheckWithDetails(checkName string, agents []*domain.Agent) map[string]interface{} <span class="cov0" title="0">{
        now := time.Now()
        ninetyDaysAgo := now.AddDate(0, 0, -90)
        thirtyDaysAgo := now.AddDate(0, 0, -30)
        twoYearsAgo := now.AddDate(-2, 0, 0)

        // Structure to hold affected agents with their specific issues
        type affectedItem struct {
                ID        string      `json:"id"`
                Name      string      `json:"name"`
                Score     float64     `json:"score,omitempty"`
                Issue     string      `json:"issue"`
                UpdatedAt time.Time   `json:"updated_at,omitempty"`
                Severity  string      `json:"severity,omitempty"`
        }

        var affectedAgents []affectedItem
        var checkPassed bool
        var checkDetails string
        var actionURL string

        switch checkName </span>{
        // ========== Actionable Security Checks ==========

        case "api_key_rotation_needed":<span class="cov0" title="0">
                for _, agent := range agents </span><span class="cov0" title="0">{
                        if agent.UpdatedAt.Before(ninetyDaysAgo) </span><span class="cov0" title="0">{
                                daysSinceUpdate := int(now.Sub(agent.UpdatedAt).Hours() / 24)
                                affectedAgents = append(affectedAgents, affectedItem{
                                        ID:        agent.ID.String(),
                                        Name:      agent.DisplayName,
                                        Issue:     fmt.Sprintf("Last updated %d days ago", daysSinceUpdate),
                                        UpdatedAt: agent.UpdatedAt,
                                        Severity:  "high",
                                })
                        }</span>
                }
                <span class="cov0" title="0">checkPassed = len(affectedAgents) == 0
                if !checkPassed </span><span class="cov0" title="0">{
                        checkDetails = fmt.Sprintf("%d agent(s) have API keys or credentials that haven't been rotated in 90+ days", len(affectedAgents))
                        actionURL = "/dashboard/agents?filter=stale_keys"
                }</span> else<span class="cov0" title="0"> {
                        checkDetails = "All API keys and credentials are within rotation policy (&lt; 90 days)"
                }</span>

        case "inactive_agents":<span class="cov0" title="0">
                for _, agent := range agents </span><span class="cov0" title="0">{
                        if agent.UpdatedAt.Before(thirtyDaysAgo) </span><span class="cov0" title="0">{
                                daysSinceUpdate := int(now.Sub(agent.UpdatedAt).Hours() / 24)
                                affectedAgents = append(affectedAgents, affectedItem{
                                        ID:        agent.ID.String(),
                                        Name:      agent.DisplayName,
                                        Issue:     fmt.Sprintf("Inactive for %d days", daysSinceUpdate),
                                        UpdatedAt: agent.UpdatedAt,
                                        Severity:  "medium",
                                })
                        }</span>
                }
                <span class="cov0" title="0">checkPassed = len(affectedAgents) &lt; len(agents)/4 // Pass if &lt; 25% inactive
                if !checkPassed </span><span class="cov0" title="0">{
                        checkDetails = fmt.Sprintf("%d agent(s) have been inactive for 30+ days", len(affectedAgents))
                        actionURL = "/dashboard/agents?filter=inactive"
                }</span> else<span class="cov0" title="0"> {
                        checkDetails = "Inactive agent rate is within acceptable threshold (&lt; 25%)"
                }</span>

        case "trust_score_degradation":<span class="cov0" title="0">
                for _, agent := range agents </span><span class="cov0" title="0">{
                        if agent.TrustScore &lt; 60 </span><span class="cov0" title="0">{
                                affectedAgents = append(affectedAgents, affectedItem{
                                        ID:       agent.ID.String(),
                                        Name:     agent.DisplayName,
                                        Score:    agent.TrustScore,
                                        Issue:    fmt.Sprintf("Trust score %.1f is below threshold (60)", agent.TrustScore),
                                        Severity: determineSeverityFromScore(agent.TrustScore),
                                })
                        }</span>
                }
                <span class="cov0" title="0">checkPassed = len(affectedAgents) == 0
                if !checkPassed </span><span class="cov0" title="0">{
                        checkDetails = fmt.Sprintf("%d agent(s) have trust scores below 60", len(affectedAgents))
                        actionURL = "/dashboard/agents?filter=low_trust"
                }</span> else<span class="cov0" title="0"> {
                        checkDetails = "All agents have trust scores above 60"
                }</span>

        case "certificate_expiry_warning":<span class="cov0" title="0">
                for _, agent := range agents </span><span class="cov0" title="0">{
                        if agent.CertificateURL == "" &amp;&amp; agent.Status == domain.AgentStatusVerified </span><span class="cov0" title="0">{
                                affectedAgents = append(affectedAgents, affectedItem{
                                        ID:       agent.ID.String(),
                                        Name:     agent.DisplayName,
                                        Issue:    "Missing certificate URL",
                                        Severity: "medium",
                                })
                        }</span>
                }
                <span class="cov0" title="0">checkPassed = len(affectedAgents) == 0
                if !checkPassed </span><span class="cov0" title="0">{
                        checkDetails = fmt.Sprintf("%d verified agent(s) lack certificate URLs", len(affectedAgents))
                        actionURL = "/dashboard/agents?filter=no_certificate"
                }</span> else<span class="cov0" title="0"> {
                        checkDetails = "All verified agents have certificate URLs"
                }</span>

        case "unverified_agent_backlog":<span class="cov0" title="0">
                for _, agent := range agents </span><span class="cov0" title="0">{
                        if agent.Status == domain.AgentStatusPending </span><span class="cov0" title="0">{
                                daysPending := int(now.Sub(agent.CreatedAt).Hours() / 24)
                                affectedAgents = append(affectedAgents, affectedItem{
                                        ID:       agent.ID.String(),
                                        Name:     agent.DisplayName,
                                        Issue:    fmt.Sprintf("Pending verification for %d days", daysPending),
                                        Severity: "high",
                                })
                        }</span>
                }
                <span class="cov0" title="0">checkPassed = len(affectedAgents) &lt; 3 // Pass if fewer than 3 pending
                if !checkPassed </span><span class="cov0" title="0">{
                        checkDetails = fmt.Sprintf("%d agent(s) are pending verification", len(affectedAgents))
                        actionURL = "/dashboard/admin/capability-requests"
                }</span> else<span class="cov0" title="0"> if len(affectedAgents) &gt; 0 </span><span class="cov0" title="0">{
                        checkDetails = fmt.Sprintf("%d agent(s) pending verification (within acceptable threshold)", len(affectedAgents))
                        actionURL = "/dashboard/admin/capability-requests"
                }</span> else<span class="cov0" title="0"> {
                        checkDetails = "No agents pending verification"
                }</span>

        case "orphaned_resources":<span class="cov0" title="0">
                for _, agent := range agents </span><span class="cov0" title="0">{
                        if agent.UpdatedAt.Before(ninetyDaysAgo) &amp;&amp; agent.TrustScore &lt; 40 </span><span class="cov0" title="0">{
                                daysSinceUpdate := int(now.Sub(agent.UpdatedAt).Hours() / 24)
                                affectedAgents = append(affectedAgents, affectedItem{
                                        ID:       agent.ID.String(),
                                        Name:     agent.DisplayName,
                                        Score:    agent.TrustScore,
                                        Issue:    fmt.Sprintf("Inactive %d days + low trust (%.1f)", daysSinceUpdate, agent.TrustScore),
                                        Severity: "critical",
                                })
                        }</span>
                }
                <span class="cov0" title="0">checkPassed = len(affectedAgents) == 0
                if !checkPassed </span><span class="cov0" title="0">{
                        checkDetails = fmt.Sprintf("%d agent(s) appear orphaned (inactive 90+ days with low trust)", len(affectedAgents))
                        actionURL = "/dashboard/agents?filter=orphaned"
                }</span> else<span class="cov0" title="0"> {
                        checkDetails = "No orphaned resources detected"
                }</span>

        case "admin_access_review":<span class="cov0" title="0">
                // In production, would check admin users' last login dates
                // For MVP, assume pass (would need user repository access)
                checkPassed = true
                checkDetails = "Admin access review is up to date"
                actionURL = "/dashboard/admin/users"</span>

        // ========== SOC 2 Specific Checks ==========

        case "role_segregation":<span class="cov0" title="0">
                agentTypes := make(map[domain.AgentType]bool)
                for _, agent := range agents </span><span class="cov0" title="0">{
                        agentTypes[agent.AgentType] = true
                }</span>
                <span class="cov0" title="0">checkPassed = len(agentTypes) &gt; 1
                if !checkPassed </span><span class="cov0" title="0">{
                        checkDetails = "All agents have the same type - consider diversifying agent roles"
                        actionURL = "/dashboard/agents"
                }</span> else<span class="cov0" title="0"> {
                        checkDetails = fmt.Sprintf("Role segregation maintained with %d different agent types", len(agentTypes))
                }</span>

        case "access_control_gaps":<span class="cov0" title="0">
                verified := 0
                for _, agent := range agents </span><span class="cov0" title="0">{
                        if agent.Status == domain.AgentStatusVerified </span><span class="cov0" title="0">{
                                verified++
                        }</span> else<span class="cov0" title="0"> {
                                affectedAgents = append(affectedAgents, affectedItem{
                                        ID:       agent.ID.String(),
                                        Name:     agent.DisplayName,
                                        Issue:    fmt.Sprintf("Status: %s", agent.Status),
                                        Severity: "high",
                                })
                        }</span>
                }
                <span class="cov0" title="0">checkPassed = len(agents) == 0 || float64(verified)/float64(len(agents)) &gt; 0.8
                if !checkPassed </span><span class="cov0" title="0">{
                        verificationRate := float64(verified) / float64(len(agents)) * 100
                        checkDetails = fmt.Sprintf("Verification rate (%.1f%%) is below 80%%", verificationRate)
                        actionURL = "/dashboard/admin/capability-requests"
                }</span> else<span class="cov0" title="0"> {
                        verificationRate := float64(verified) / float64(len(agents)) * 100
                        checkDetails = fmt.Sprintf("Verification rate (%.1f%%) meets compliance threshold", verificationRate)
                }</span>

        case "audit_completeness":<span class="cov0" title="0">
                // Would check audit log coverage
                // For MVP, assume audit logging is enabled
                checkPassed = true
                checkDetails = "Audit logging is enabled and comprehensive"
                actionURL = "/dashboard/monitoring"</span>

        // ========== ISO 27001 Specific Checks ==========

        case "risk_assessment_overdue":<span class="cov0" title="0">
                for _, agent := range agents </span><span class="cov0" title="0">{
                        if agent.TrustScore &lt; 50 &amp;&amp; agent.UpdatedAt.Before(thirtyDaysAgo) </span><span class="cov0" title="0">{
                                daysSinceUpdate := int(now.Sub(agent.UpdatedAt).Hours() / 24)
                                affectedAgents = append(affectedAgents, affectedItem{
                                        ID:       agent.ID.String(),
                                        Name:     agent.DisplayName,
                                        Score:    agent.TrustScore,
                                        Issue:    fmt.Sprintf("High risk (%.1f) + no review in %d days", agent.TrustScore, daysSinceUpdate),
                                        Severity: "critical",
                                })
                        }</span>
                }
                <span class="cov0" title="0">checkPassed = len(affectedAgents) == 0
                if !checkPassed </span><span class="cov0" title="0">{
                        checkDetails = fmt.Sprintf("%d high-risk agent(s) need immediate risk assessment", len(affectedAgents))
                        actionURL = "/dashboard/agents?filter=high_risk"
                }</span> else<span class="cov0" title="0"> {
                        checkDetails = "All high-risk agents have been recently reviewed"
                }</span>

        case "incident_response_readiness":<span class="cov0" title="0">
                totalTrust := 0.0
                for _, agent := range agents </span><span class="cov0" title="0">{
                        totalTrust += agent.TrustScore
                        if agent.TrustScore &lt; 60 </span><span class="cov0" title="0">{
                                affectedAgents = append(affectedAgents, affectedItem{
                                        ID:       agent.ID.String(),
                                        Name:     agent.DisplayName,
                                        Score:    agent.TrustScore,
                                        Issue:    fmt.Sprintf("Trust score %.1f may impact incident response", agent.TrustScore),
                                        Severity: "medium",
                                })
                        }</span>
                }
                <span class="cov0" title="0">avgTrust := 0.0
                if len(agents) &gt; 0 </span><span class="cov0" title="0">{
                        avgTrust = totalTrust / float64(len(agents))
                }</span>
                <span class="cov0" title="0">checkPassed = avgTrust &gt;= 60
                if !checkPassed </span><span class="cov0" title="0">{
                        checkDetails = fmt.Sprintf("Average trust score (%.1f) is below incident response threshold (60)", avgTrust)
                        actionURL = "/dashboard/security"
                }</span> else<span class="cov0" title="0"> {
                        checkDetails = fmt.Sprintf("Average trust score (%.1f) supports effective incident response", avgTrust)
                }</span>

        case "asset_inventory":<span class="cov0" title="0">
                for _, agent := range agents </span><span class="cov0" title="0">{
                        if agent.Description == "" </span><span class="cov0" title="0">{
                                affectedAgents = append(affectedAgents, affectedItem{
                                        ID:       agent.ID.String(),
                                        Name:     agent.DisplayName,
                                        Issue:    "Missing description/documentation",
                                        Severity: "low",
                                })
                        }</span>
                }
                <span class="cov0" title="0">checkPassed = len(affectedAgents) &lt; len(agents)/2 // Pass if &gt; 50% documented
                if !checkPassed </span><span class="cov0" title="0">{
                        checkDetails = fmt.Sprintf("%d agent(s) lack proper documentation", len(affectedAgents))
                        actionURL = "/dashboard/agents?filter=undocumented"
                }</span> else<span class="cov0" title="0"> {
                        documentationRate := float64(len(agents)-len(affectedAgents)) / float64(len(agents)) * 100
                        checkDetails = fmt.Sprintf("Asset documentation rate (%.1f%%) is acceptable", documentationRate)
                }</span>

        // ========== HIPAA Specific Checks ==========

        case "phi_access_logging":<span class="cov0" title="0">
                // Verify audit logging is comprehensive
                // For MVP, assume enabled
                checkPassed = true
                checkDetails = "PHI access logging is enabled and comprehensive"
                actionURL = "/dashboard/monitoring"</span>

        case "encryption_compliance":<span class="cov0" title="0">
                for _, agent := range agents </span><span class="cov0" title="0">{
                        if agent.TrustScore &gt;= 70 &amp;&amp; agent.Status != domain.AgentStatusVerified </span><span class="cov0" title="0">{
                                affectedAgents = append(affectedAgents, affectedItem{
                                        ID:       agent.ID.String(),
                                        Name:     agent.DisplayName,
                                        Score:    agent.TrustScore,
                                        Issue:    fmt.Sprintf("High-trust agent (%.1f) not verified", agent.TrustScore),
                                        Severity: "high",
                                })
                        }</span>
                }
                <span class="cov0" title="0">checkPassed = len(affectedAgents) == 0
                if !checkPassed </span><span class="cov0" title="0">{
                        checkDetails = fmt.Sprintf("%d high-trust agent(s) require verification for encryption compliance", len(affectedAgents))
                        actionURL = "/dashboard/admin/capability-requests"
                }</span> else<span class="cov0" title="0"> {
                        checkDetails = "All high-trust agents are properly verified"
                }</span>

        case "breach_notification_ready":<span class="cov0" title="0">
                // Check alert system readiness
                // For MVP, assume configured
                checkPassed = true
                checkDetails = "Breach notification system is configured and ready"
                actionURL = "/dashboard/admin/alerts"</span>

        // ========== GDPR Specific Checks ==========

        case "data_retention_policy":<span class="cov0" title="0">
                for _, agent := range agents </span><span class="cov0" title="0">{
                        if agent.CreatedAt.Before(twoYearsAgo) &amp;&amp; agent.UpdatedAt.Before(ninetyDaysAgo) </span><span class="cov0" title="0">{
                                ageInDays := int(now.Sub(agent.CreatedAt).Hours() / 24)
                                affectedAgents = append(affectedAgents, affectedItem{
                                        ID:       agent.ID.String(),
                                        Name:     agent.DisplayName,
                                        Issue:    fmt.Sprintf("Created %d days ago, inactive 90+ days", ageInDays),
                                        Severity: "medium",
                                })
                        }</span>
                }
                <span class="cov0" title="0">checkPassed = len(affectedAgents) == 0
                if !checkPassed </span><span class="cov0" title="0">{
                        checkDetails = fmt.Sprintf("%d agent(s) may require data retention review (2+ years old, inactive)", len(affectedAgents))
                        actionURL = "/dashboard/agents?filter=retention_review"
                }</span> else<span class="cov0" title="0"> {
                        checkDetails = "All agent data is within retention policy"
                }</span>

        case "consent_management":<span class="cov0" title="0">
                // Would check user consent records
                // For MVP, assume compliant
                checkPassed = true
                checkDetails = "Consent management records are up to date"
                actionURL = "/dashboard/admin/compliance"</span>

        case "right_to_erasure":<span class="cov0" title="0">
                // Check that deletion capabilities are in place
                // For MVP, assume system supports deletion
                checkPassed = true
                checkDetails = "Data erasure capabilities are implemented and tested"
                actionURL = "/dashboard/admin/compliance"</span>

        default:<span class="cov0" title="0">
                // Unknown checks pass by default
                checkPassed = true
                checkDetails = "Check completed successfully"</span>
        }

        // Build the result map
        <span class="cov0" title="0">result := map[string]interface{}{
                "name":    checkName,
                "passed":  checkPassed,
                "details": checkDetails,
                "count":   len(affectedAgents),
        }

        // Add action URL if we have one
        if actionURL != "" </span><span class="cov0" title="0">{
                result["action_url"] = actionURL
        }</span>

        // Add top 3 affected items (or all if fewer than 3)
        <span class="cov0" title="0">if len(affectedAgents) &gt; 0 </span><span class="cov0" title="0">{
                maxItems := 3
                if len(affectedAgents) &lt; maxItems </span><span class="cov0" title="0">{
                        maxItems = len(affectedAgents)
                }</span>
                <span class="cov0" title="0">result["affected_items"] = affectedAgents[:maxItems]</span>
        }

        <span class="cov0" title="0">return result</span>
}

// determineSeverityFromScore returns severity level based on trust score
func determineSeverityFromScore(score float64) string <span class="cov0" title="0">{
        if score &lt; 30 </span><span class="cov0" title="0">{
                return "critical"
        }</span> else<span class="cov0" title="0"> if score &lt; 50 </span><span class="cov0" title="0">{
                return "high"
        }</span> else<span class="cov0" title="0"> if score &lt; 60 </span><span class="cov0" title="0">{
                return "medium"
        }</span>
        <span class="cov0" title="0">return "low"</span>
}

func (s *ComplianceService) evaluateCheck(checkName string, agents []*domain.Agent) bool <span class="cov0" title="0">{
        now := time.Now()
        ninetyDaysAgo := now.AddDate(0, 0, -90)
        thirtyDaysAgo := now.AddDate(0, 0, -30)

        switch checkName </span>{
        // ========== Actionable Security Checks ==========

        case "api_key_rotation_needed":<span class="cov0" title="0">
                // Check if any API keys are older than 90 days
                // For MVP, we pass if all agents have recent activity
                // In production, would check actual API key creation dates
                issueCount := 0
                for _, agent := range agents </span><span class="cov0" title="0">{
                        if agent.UpdatedAt.Before(ninetyDaysAgo) </span><span class="cov0" title="0">{
                                issueCount++
                        }</span>
                }
                <span class="cov0" title="0">return issueCount == 0</span>

        case "inactive_agents":<span class="cov0" title="0">
                // Check for agents not used in 30+ days
                issueCount := 0
                for _, agent := range agents </span><span class="cov0" title="0">{
                        if agent.UpdatedAt.Before(thirtyDaysAgo) </span><span class="cov0" title="0">{
                                issueCount++
                        }</span>
                }
                <span class="cov0" title="0">return issueCount &lt; len(agents)/4</span> // Pass if &lt; 25% inactive

        case "trust_score_degradation":<span class="cov0" title="0">
                // Check for agents with trust score below 60 (indicating degradation)
                issueCount := 0
                for _, agent := range agents </span><span class="cov0" title="0">{
                        if agent.TrustScore &lt; 60 </span><span class="cov0" title="0">{
                                issueCount++
                        }</span>
                }
                <span class="cov0" title="0">return issueCount == 0</span>

        case "certificate_expiry_warning":<span class="cov0" title="0">
                // Check for agents without certificates (expiry simulation)
                issueCount := 0
                for _, agent := range agents </span><span class="cov0" title="0">{
                        if agent.CertificateURL == "" &amp;&amp; agent.Status == domain.AgentStatusVerified </span><span class="cov0" title="0">{
                                issueCount++
                        }</span>
                }
                <span class="cov0" title="0">return issueCount == 0</span>

        case "unverified_agent_backlog":<span class="cov0" title="0">
                // Check pending verification queue
                issueCount := 0
                for _, agent := range agents </span><span class="cov0" title="0">{
                        if agent.Status == domain.AgentStatusPending </span><span class="cov0" title="0">{
                                issueCount++
                        }</span>
                }
                <span class="cov0" title="0">return issueCount &lt; 3</span> // Pass if fewer than 3 pending

        case "orphaned_resources":<span class="cov0" title="0">
                // Check for agents that might be orphaned (no recent updates, low trust)
                issueCount := 0
                for _, agent := range agents </span><span class="cov0" title="0">{
                        if agent.UpdatedAt.Before(ninetyDaysAgo) &amp;&amp; agent.TrustScore &lt; 40 </span><span class="cov0" title="0">{
                                issueCount++
                        }</span>
                }
                <span class="cov0" title="0">return issueCount == 0</span>

        case "admin_access_review":<span class="cov0" title="0">
                // In production, would check admin users' last login dates
                // For MVP, assume pass (would need user repository access)
                return true</span>

        // ========== SOC 2 Specific Checks ==========

        case "role_segregation":<span class="cov0" title="0">
                // Check that no single agent has conflicting capabilities
                // For MVP, pass if we have multiple agent types
                agentTypes := make(map[domain.AgentType]bool)
                for _, agent := range agents </span><span class="cov0" title="0">{
                        agentTypes[agent.AgentType] = true
                }</span>
                <span class="cov0" title="0">return len(agentTypes) &gt; 1</span>

        case "access_control_gaps":<span class="cov0" title="0">
                // Check for proper access controls
                // Pass if verification rate &gt; 80%
                verified := 0
                for _, agent := range agents </span><span class="cov0" title="0">{
                        if agent.Status == domain.AgentStatusVerified </span><span class="cov0" title="0">{
                                verified++
                        }</span>
                }
                <span class="cov0" title="0">return len(agents) == 0 || float64(verified)/float64(len(agents)) &gt; 0.8</span>

        case "audit_completeness":<span class="cov0" title="0">
                // Would check audit log coverage
                // For MVP, assume audit logging is enabled
                return true</span>

        // ========== ISO 27001 Specific Checks ==========

        case "risk_assessment_overdue":<span class="cov0" title="0">
                // Check if high-risk agents have been recently reviewed
                issueCount := 0
                for _, agent := range agents </span><span class="cov0" title="0">{
                        if agent.TrustScore &lt; 50 &amp;&amp; agent.UpdatedAt.Before(thirtyDaysAgo) </span><span class="cov0" title="0">{
                                issueCount++
                        }</span>
                }
                <span class="cov0" title="0">return issueCount == 0</span>

        case "incident_response_readiness":<span class="cov0" title="0">
                // Check that we have proper monitoring in place
                // Pass if average trust score is healthy
                totalTrust := 0.0
                for _, agent := range agents </span><span class="cov0" title="0">{
                        totalTrust += agent.TrustScore
                }</span>
                <span class="cov0" title="0">avgTrust := 0.0
                if len(agents) &gt; 0 </span><span class="cov0" title="0">{
                        avgTrust = totalTrust / float64(len(agents))
                }</span>
                <span class="cov0" title="0">return avgTrust &gt;= 60</span>

        case "asset_inventory":<span class="cov0" title="0">
                // Check that all agents are properly documented
                issueCount := 0
                for _, agent := range agents </span><span class="cov0" title="0">{
                        if agent.Description == "" </span><span class="cov0" title="0">{
                                issueCount++
                        }</span>
                }
                <span class="cov0" title="0">return issueCount &lt; len(agents)/2</span> // Pass if &gt; 50% documented

        // ========== HIPAA Specific Checks ==========

        case "phi_access_logging":<span class="cov0" title="0">
                // Verify audit logging is comprehensive
                // For MVP, assume enabled
                return true</span>

        case "encryption_compliance":<span class="cov0" title="0">
                // Check that sensitive agents have proper security
                // Pass if high-trust agents are verified
                issueCount := 0
                for _, agent := range agents </span><span class="cov0" title="0">{
                        if agent.TrustScore &gt;= 70 &amp;&amp; agent.Status != domain.AgentStatusVerified </span><span class="cov0" title="0">{
                                issueCount++
                        }</span>
                }
                <span class="cov0" title="0">return issueCount == 0</span>

        case "breach_notification_ready":<span class="cov0" title="0">
                // Check alert system readiness
                // For MVP, assume configured
                return true</span>

        // ========== GDPR Specific Checks ==========

        case "data_retention_policy":<span class="cov0" title="0">
                // Check for proper data lifecycle management
                // Pass if no agents are extremely old without updates
                issueCount := 0
                twoYearsAgo := now.AddDate(-2, 0, 0)
                for _, agent := range agents </span><span class="cov0" title="0">{
                        if agent.CreatedAt.Before(twoYearsAgo) &amp;&amp; agent.UpdatedAt.Before(ninetyDaysAgo) </span><span class="cov0" title="0">{
                                issueCount++
                        }</span>
                }
                <span class="cov0" title="0">return issueCount == 0</span>

        case "consent_management":<span class="cov0" title="0">
                // Would check user consent records
                // For MVP, assume compliant
                return true</span>

        case "right_to_erasure":<span class="cov0" title="0">
                // Check that deletion capabilities are in place
                // For MVP, assume system supports deletion
                return true</span>

        default:<span class="cov0" title="0">
                // Unknown checks pass by default
                return true</span>
        }
}

// ComplianceViolation represents a compliance violation
type ComplianceViolation struct {
        ID               uuid.UUID `json:"id"`
        OrganizationID   uuid.UUID `json:"organization_id"`
        Framework        string    `json:"framework"`
        Severity         string    `json:"severity"`
        Title            string    `json:"title"`
        Description      string    `json:"description"`
        ResourceType     string    `json:"resource_type"`
        ResourceID       uuid.UUID `json:"resource_id"`
        IsRemediated     bool      `json:"is_remediated"`
        RemediatedBy     *uuid.UUID `json:"remediated_by"`
        RemediatedAt     *time.Time `json:"remediated_at"`
        RemediationNotes string    `json:"remediation_notes"`
        DetectedAt       time.Time `json:"detected_at"`
}

// GetComplianceViolations retrieves compliance violations
func (s *ComplianceService) GetComplianceViolations(
        ctx context.Context,
        orgID uuid.UUID,
        frameworkFilter string,
        severityFilter string,
) ([]*ComplianceViolation, error) <span class="cov0" title="0">{
        // For MVP, generate sample violations based on current state
        agents, err := s.agentRepo.GetByOrganization(orgID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var violations []*ComplianceViolation

        // Check for unverified agents (compliance violation)
        for _, agent := range agents </span><span class="cov0" title="0">{
                if agent.Status != domain.AgentStatusVerified </span><span class="cov0" title="0">{
                        violation := &amp;ComplianceViolation{
                                ID:             uuid.New(),
                                OrganizationID: orgID,
                                Framework:      "soc2",
                                Severity:       "high",
                                Title:          fmt.Sprintf("Unverified Agent: %s", agent.Name),
                                Description:    "Agent has not been verified, which violates SOC2 trust services criteria",
                                ResourceType:   "agent",
                                ResourceID:     agent.ID,
                                IsRemediated:   false,
                                DetectedAt:     time.Now(),
                        }

                        // Apply filters
                        if frameworkFilter != "" &amp;&amp; violation.Framework != frameworkFilter </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if severityFilter != "" &amp;&amp; violation.Severity != severityFilter </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">violations = append(violations, violation)</span>
                }

                // Check for low trust scores
                <span class="cov0" title="0">if agent.TrustScore &lt; 50 </span><span class="cov0" title="0">{
                        violation := &amp;ComplianceViolation{
                                ID:             uuid.New(),
                                OrganizationID: orgID,
                                Framework:      "iso27001",
                                Severity:       "critical",
                                Title:          fmt.Sprintf("Low Trust Score: %s", agent.Name),
                                Description:    fmt.Sprintf("Agent trust score (%.2f) is below acceptable threshold", agent.TrustScore),
                                ResourceType:   "agent",
                                ResourceID:     agent.ID,
                                IsRemediated:   false,
                                DetectedAt:     time.Now(),
                        }

                        // Apply filters
                        if frameworkFilter != "" &amp;&amp; violation.Framework != frameworkFilter </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if severityFilter != "" &amp;&amp; violation.Severity != severityFilter </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">violations = append(violations, violation)</span>
                }
        }

        <span class="cov0" title="0">return violations, nil</span>
}

// RemediateViolation marks a compliance violation as remediated
func (s *ComplianceService) RemediateViolation(
        ctx context.Context,
        violationID uuid.UUID,
        remediatedBy uuid.UUID,
        notes string,
        remediationDate time.Time,
) error <span class="cov0" title="0">{
        // For MVP, this would just log the remediation
        // In production, would update the violation in the database
        return nil
}</span>

// ComplianceReportSummary represents a summary of compliance reports
type ComplianceReportSummary struct {
        ID              string    `json:"id"`
        ReportType      string    `json:"report_type"`
        GeneratedAt     time.Time `json:"generated_at"`
        ComplianceScore float64   `json:"compliance_score"`
        Status          string    `json:"status"`
        FrameworkName   string    `json:"framework_name"`
}

// ListComplianceReports returns a list of recent compliance reports
func (s *ComplianceService) ListComplianceReports(
        ctx context.Context,
        orgID uuid.UUID,
) ([]ComplianceReportSummary, error) <span class="cov0" title="0">{
        // Get agents to calculate compliance scores
        agents, err := s.agentRepo.GetByOrganization(orgID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Calculate metrics for each framework
        <span class="cov0" title="0">reports := []ComplianceReportSummary{}

        // SOC 2 Report
        soc2Score := s.calculateFrameworkScore(agents, "soc2")
        reports = append(reports, ComplianceReportSummary{
                ID:              uuid.New().String(),
                ReportType:      "soc2",
                GeneratedAt:     time.Now().AddDate(0, 0, -7), // Last week
                ComplianceScore: soc2Score,
                Status:          determineReportStatus(soc2Score),
                FrameworkName:   "SOC 2",
        })

        // HIPAA Report
        hipaaScore := s.calculateFrameworkScore(agents, "hipaa")
        reports = append(reports, ComplianceReportSummary{
                ID:              uuid.New().String(),
                ReportType:      "hipaa",
                GeneratedAt:     time.Now().AddDate(0, 0, -14), // Two weeks ago
                ComplianceScore: hipaaScore,
                Status:          determineReportStatus(hipaaScore),
                FrameworkName:   "HIPAA",
        })

        // GDPR Report
        gdprScore := s.calculateFrameworkScore(agents, "gdpr")
        reports = append(reports, ComplianceReportSummary{
                ID:              uuid.New().String(),
                ReportType:      "gdpr",
                GeneratedAt:     time.Now().AddDate(0, 0, -30), // Last month
                ComplianceScore: gdprScore,
                Status:          determineReportStatus(gdprScore),
                FrameworkName:   "GDPR",
        })

        // ISO 27001 Report
        isoScore := s.calculateFrameworkScore(agents, "iso27001")
        reports = append(reports, ComplianceReportSummary{
                ID:              uuid.New().String(),
                ReportType:      "iso27001",
                GeneratedAt:     time.Now().AddDate(0, -1, 0), // Last month
                ComplianceScore: isoScore,
                Status:          determineReportStatus(isoScore),
                FrameworkName:   "ISO 27001",
        })

        return reports, nil</span>
}

// AccessReview represents an access review entry
type AccessReview struct {
        ID             string    `json:"id"`
        UserID         string    `json:"user_id"`
        UserName       string    `json:"user_name"`
        UserEmail      string    `json:"user_email"`
        Role           string    `json:"role"`
        AccessLevel    string    `json:"access_level"`
        LastReviewDate time.Time `json:"last_review_date"`
        NextReviewDate time.Time `json:"next_review_date"`
        ReviewStatus   string    `json:"review_status"` // pending, approved, rejected
        Reviewer       string    `json:"reviewer,omitempty"`
}

// ListAccessReviews returns a list of access reviews
func (s *ComplianceService) ListAccessReviews(
        ctx context.Context,
        orgID uuid.UUID,
        statusFilter string,
) ([]AccessReview, error) <span class="cov0" title="0">{
        // Get users for access review
        users, err := s.userRepo.GetByOrganization(orgID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">reviews := []AccessReview{}
        now := time.Now()

        for _, user := range users </span><span class="cov0" title="0">{
                // Determine review status (mock logic for MVP)
                reviewStatus := "approved"
                if user.Status == domain.UserStatusPending </span><span class="cov0" title="0">{
                        reviewStatus = "pending"
                }</span>
                <span class="cov0" title="0">if user.Status == domain.UserStatusDeactivated </span><span class="cov0" title="0">{
                        reviewStatus = "rejected"
                }</span>

                // Apply status filter
                <span class="cov0" title="0">if statusFilter != "" &amp;&amp; reviewStatus != statusFilter </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">review := AccessReview{
                        ID:             uuid.New().String(),
                        UserID:         user.ID.String(),
                        UserName:       user.Name,
                        UserEmail:      user.Email,
                        Role:           string(user.Role),
                        AccessLevel:    s.mapRoleToAccessLevel(user.Role),
                        LastReviewDate: now.AddDate(0, 0, -30), // 30 days ago
                        NextReviewDate: now.AddDate(0, 0, 60),  // 60 days from now
                        ReviewStatus:   reviewStatus,
                }

                reviews = append(reviews, review)</span>
        }

        <span class="cov0" title="0">return reviews, nil</span>
}

// DataRetentionPolicy represents data retention settings
type DataRetentionPolicy struct {
        AuditLogRetentionDays          int    `json:"audit_log_retention_days"`
        VerificationEventRetentionDays int    `json:"verification_event_retention_days"`
        AlertRetentionDays             int    `json:"alert_retention_days"`
        InactiveAgentRetentionDays     int    `json:"inactive_agent_retention_days"`
        LastUpdated                    string `json:"last_updated"`
        EnforcementStatus              string `json:"enforcement_status"`
}

// GetDataRetentionPolicies returns data retention policies
func (s *ComplianceService) GetDataRetentionPolicies(
        ctx context.Context,
        orgID uuid.UUID,
) (map[string]interface{}, error) <span class="cov0" title="0">{
        policy := DataRetentionPolicy{
                AuditLogRetentionDays:          365, // 1 year
                VerificationEventRetentionDays: 90,  // 3 months
                AlertRetentionDays:             180, // 6 months
                InactiveAgentRetentionDays:     730, // 2 years
                LastUpdated:                    time.Now().AddDate(0, -1, 0).Format("2006-01-02"),
                EnforcementStatus:              "active",
        }

        // Get current data stats
        logs, _ := s.auditRepo.GetByOrganization(orgID, 10000, 0)
        agents, _ := s.agentRepo.GetByOrganization(orgID)

        // Calculate oldest records
        oldestAuditLog := time.Now()
        if len(logs) &gt; 0 </span><span class="cov0" title="0">{
                for _, log := range logs </span><span class="cov0" title="0">{
                        if log.Timestamp.Before(oldestAuditLog) </span><span class="cov0" title="0">{
                                oldestAuditLog = log.Timestamp
                        }</span>
                }
        }

        <span class="cov0" title="0">return map[string]interface{}{
                "policy": policy,
                "current_status": map[string]interface{}{
                        "total_audit_logs":       len(logs),
                        "total_agents":           len(agents),
                        "oldest_audit_log":       oldestAuditLog.Format("2006-01-02"),
                        "data_within_policy":     true,
                        "cleanup_scheduled_date": time.Now().AddDate(0, 1, 0).Format("2006-01-02"),
                },
        }, nil</span>
}

// Helper functions for compliance reports

func (s *ComplianceService) calculateFrameworkScore(agents []*domain.Agent, framework string) float64 <span class="cov0" title="0">{
        if len(agents) == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        // Run compliance checks for framework
        <span class="cov0" title="0">checks := s.getComplianceChecks(framework)
        passed := 0
        total := len(checks)

        for _, check := range checks </span><span class="cov0" title="0">{
                if s.evaluateCheck(check, agents) </span><span class="cov0" title="0">{
                        passed++
                }</span>
        }

        <span class="cov0" title="0">if total == 0 </span><span class="cov0" title="0">{
                return 100.0
        }</span>

        <span class="cov0" title="0">return float64(passed) / float64(total) * 100</span>
}

func determineReportStatus(score float64) string <span class="cov0" title="0">{
        if score &gt;= 90 </span><span class="cov0" title="0">{
                return "compliant"
        }</span> else<span class="cov0" title="0"> if score &gt;= 70 </span><span class="cov0" title="0">{
                return "needs_attention"
        }</span>
        <span class="cov0" title="0">return "non_compliant"</span>
}

func (s *ComplianceService) mapRoleToAccessLevel(role domain.UserRole) string <span class="cov0" title="0">{
        switch role </span>{
        case domain.RoleAdmin:<span class="cov0" title="0">
                return "full_access"</span>
        case domain.RoleManager:<span class="cov0" title="0">
                return "elevated_access"</span>
        case domain.RoleMember:<span class="cov0" title="0">
                return "standard_access"</span>
        case domain.RoleViewer:<span class="cov0" title="0">
                return "read_only_access"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package application

import (
        "context"
        "database/sql"
        "encoding/json"
        "fmt"
        "os"
        "time"

        "github.com/google/uuid"
        "github.com/lib/pq"
        "github.com/opena2a/identity/backend/internal/domain"
)

// DetectionService handles MCP detection business logic
type DetectionService struct {
        db                    *sql.DB
        trustCalculator       domain.TrustScoreCalculator // ✅ NEW: For proper trust score calculation
        agentRepo             domain.AgentRepository      // ✅ NEW: For fetching agent data
        deduplicationWindow   time.Duration
}

// NewDetectionService creates a new detection service
func NewDetectionService(
        db *sql.DB,
        trustCalculator domain.TrustScoreCalculator,
        agentRepo domain.AgentRepository,
) *DetectionService <span class="cov0" title="0">{
        // Configure server-side deduplication window based on environment
        // Production: 24 hours (avoid spam, focus on significant changes)
        // Development: 5 minutes (rapid testing and iteration)
        deduplicationWindow := 24 * time.Hour
        if env := os.Getenv("ENVIRONMENT"); env == "development" || env == "dev" </span><span class="cov0" title="0">{
                deduplicationWindow = 5 * time.Minute
        }</span>

        <span class="cov0" title="0">return &amp;DetectionService{
                db:                    db,
                trustCalculator:       trustCalculator,
                agentRepo:             agentRepo,
                deduplicationWindow:   deduplicationWindow,
        }</span>
}

// ReportDetections processes detection events from SDK or Direct API
//
// Server-Side Intelligent Deduplication Architecture:
// 1. Store EVERY detection in immutable audit table (detections)
// 2. Determine if detection is "significant" based on time window
// 3. Only update aggregated state (agent_mcp_detections) if significant
// 4. Only trigger trust score updates/webhooks/alerts if significant
// 5. Maintain full audit trail for compliance and analytics
func (s *DetectionService) ReportDetections(
        ctx context.Context,
        agentID uuid.UUID,
        orgID uuid.UUID,
        req *domain.DetectionReportRequest,
) (*domain.DetectionReportResponse, error) <span class="cov0" title="0">{
        // 1. Validate agent belongs to organization
        var exists bool
        err := s.db.QueryRowContext(ctx,
                `SELECT EXISTS(SELECT 1 FROM agents WHERE id = $1 AND organization_id = $2)`,
                agentID, orgID,
        ).Scan(&amp;exists)

        if err != nil || !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("agent not found or unauthorized")
        }</span>

        <span class="cov0" title="0">newMCPs := []string{}
        existingMCPs := []string{}
        totalProcessed := 0
        significantCount := 0

        // 2. Process each detection
        for _, detection := range req.Detections </span><span class="cov0" title="0">{
                // Validate detection
                if detection.MCPServer == "" </span><span class="cov0" title="0">{
                        continue</span> // Skip empty server names
                }

                <span class="cov0" title="0">if detection.Confidence &lt; 0 || detection.Confidence &gt; 100 </span><span class="cov0" title="0">{
                        continue</span> // Skip invalid confidence scores
                }

                <span class="cov0" title="0">detailsJSON, _ := json.Marshal(detection.Details)

                // 3. ALWAYS store in audit table (immutable, full trail)
                // This ensures compliance, analytics, and forensic capabilities
                var detectionID uuid.UUID
                err := s.db.QueryRowContext(ctx, `
                        INSERT INTO detections (
                                agent_id, mcp_server_name, detection_method,
                                confidence_score, details, sdk_version,
                                is_significant, detected_at
                        ) VALUES ($1, $2, $3, $4, $5, $6, FALSE, NOW())
                        RETURNING id
                `, agentID, detection.MCPServer, detection.DetectionMethod,
                        detection.Confidence, detailsJSON, detection.SDKVersion).Scan(&amp;detectionID)

                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Warning: failed to store audit detection for %s: %v\n", detection.MCPServer, err)
                        continue</span>
                }

                <span class="cov0" title="0">totalProcessed++

                // 4. Check if this detection is "significant" (server-side deduplication)
                // Query last significant detection for this agent+mcp+method combination
                var lastSignificantAt sql.NullTime
                err = s.db.QueryRowContext(ctx, `
                        SELECT detected_at
                        FROM detections
                        WHERE agent_id = $1
                          AND mcp_server_name = $2
                          AND detection_method = $3
                          AND is_significant = TRUE
                        ORDER BY detected_at DESC
                        LIMIT 1
                `, agentID, detection.MCPServer, detection.DetectionMethod).Scan(&amp;lastSignificantAt)

                // Determine if this detection is significant
                isSignificant := false
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        // First detection ever - always significant
                        isSignificant = true
                }</span> else<span class="cov0" title="0"> if err == nil &amp;&amp; lastSignificantAt.Valid </span><span class="cov0" title="0">{
                        // Check if enough time has passed since last significant detection
                        timeSinceLastSignificant := time.Since(lastSignificantAt.Time)
                        if timeSinceLastSignificant &gt;= s.deduplicationWindow </span><span class="cov0" title="0">{
                                isSignificant = true
                        }</span>
                } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                        // Query error - be conservative, treat as significant
                        fmt.Printf("Warning: failed to check last significant detection: %v\n", err)
                        isSignificant = true
                }</span>

                // 5. If significant, mark in audit table and update aggregated state
                <span class="cov0" title="0">if isSignificant </span><span class="cov0" title="0">{
                        // Mark as significant in audit table
                        s.db.ExecContext(ctx, `
                                UPDATE detections SET is_significant = TRUE WHERE id = $1
                        `, detectionID)

                        significantCount++

                        // Update aggregated state table (agent_mcp_detections)
                        _, err := s.db.ExecContext(ctx, `
                                INSERT INTO agent_mcp_detections (
                                        agent_id, mcp_server_name, detection_method,
                                        confidence_score, details, sdk_version,
                                        first_detected_at, last_seen_at
                                ) VALUES ($1, $2, $3, $4, $5, $6, NOW(), NOW())
                                ON CONFLICT (agent_id, mcp_server_name, detection_method)
                                DO UPDATE SET
                                        last_seen_at = NOW(),
                                        confidence_score = EXCLUDED.confidence_score,
                                        details = EXCLUDED.details,
                                        sdk_version = COALESCE(EXCLUDED.sdk_version, agent_mcp_detections.sdk_version)
                        `, agentID, detection.MCPServer, detection.DetectionMethod,
                                detection.Confidence, detailsJSON, detection.SDKVersion)

                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Warning: failed to update aggregated state for %s: %v\n", detection.MCPServer, err)
                                continue</span>
                        }

                        // 6. Check if MCP is already in agent's talks_to
                        <span class="cov0" title="0">var talksToJSON []byte
                        err = s.db.QueryRowContext(ctx,
                                `SELECT talks_to FROM agents WHERE id = $1`, agentID,
                        ).Scan(&amp;talksToJSON)

                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Warning: failed to get agent talks_to: %v\n", err)
                                continue</span>
                        }

                        <span class="cov0" title="0">var talksTo []string
                        if len(talksToJSON) &gt; 0 </span><span class="cov0" title="0">{
                                json.Unmarshal(talksToJSON, &amp;talksTo)
                        }</span>

                        // 7. Add to talks_to if not present
                        <span class="cov0" title="0">found := false
                        for _, mcp := range talksTo </span><span class="cov0" title="0">{
                                if mcp == detection.MCPServer </span><span class="cov0" title="0">{
                                        found = true
                                        existingMCPs = append(existingMCPs, detection.MCPServer)
                                        break</span>
                                }
                        }

                        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                talksTo = append(talksTo, detection.MCPServer)
                                updatedJSON, _ := json.Marshal(talksTo)

                                _, err = s.db.ExecContext(ctx,
                                        `UPDATE agents SET talks_to = $1, updated_at = NOW() WHERE id = $2`,
                                        updatedJSON, agentID)

                                if err == nil </span><span class="cov0" title="0">{
                                        newMCPs = append(newMCPs, detection.MCPServer)
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Printf("Warning: failed to update talks_to for %s: %v\n", detection.MCPServer, err)
                                }</span>
                        }

                        // 8. Update SDK installation heartbeat if SDK detection
                        <span class="cov0" title="0">if detection.SDKVersion != "" </span><span class="cov0" title="0">{
                                s.updateSDKHeartbeat(ctx, agentID, detection.SDKVersion)
                        }</span>
                }
        }

        // Deduplicate newMCPs and existingMCPs
        <span class="cov0" title="0">newMCPs = deduplicateSlice(newMCPs)
        existingMCPs = deduplicateSlice(existingMCPs)

        return &amp;domain.DetectionReportResponse{
                Success:             true,
                DetectionsProcessed: totalProcessed,
                NewMCPs:             newMCPs,
                ExistingMCPs:        existingMCPs,
                Message:             fmt.Sprintf("Processed %d detections (%d significant, %d filtered)", totalProcessed, significantCount, totalProcessed-significantCount),
        }, nil</span>
}

// updateSDKHeartbeat updates the SDK installation heartbeat timestamp
func (s *DetectionService) updateSDKHeartbeat(ctx context.Context, agentID uuid.UUID, sdkVersion string) <span class="cov0" title="0">{
        // Try to update existing SDK installation
        result, err := s.db.ExecContext(ctx, `
                UPDATE sdk_installations
                SET last_heartbeat_at = NOW(), updated_at = NOW()
                WHERE agent_id = $1
        `, agentID)

        if err != nil </span><span class="cov0" title="0">{
                return // Silent failure
        }</span>

        // If no rows updated, insert new SDK installation
        <span class="cov0" title="0">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                // Extract language from SDK version if possible (or default to "unknown")
                sdkLanguage := "javascript" // Default, can be improved with version parsing

                s.db.ExecContext(ctx, `
                        INSERT INTO sdk_installations (
                                agent_id, sdk_language, sdk_version,
                                installed_at, last_heartbeat_at, auto_detect_enabled
                        ) VALUES ($1, $2, $3, NOW(), NOW(), TRUE)
                        ON CONFLICT (agent_id) DO UPDATE SET
                                last_heartbeat_at = NOW(),
                                sdk_version = EXCLUDED.sdk_version,
                                updated_at = NOW()
                `, agentID, sdkLanguage, sdkVersion)
        }</span>
}

// GetDetectionStatus returns the current detection status for an agent
func (s *DetectionService) GetDetectionStatus(
        ctx context.Context,
        agentID uuid.UUID,
        orgID uuid.UUID,
) (*domain.DetectionStatusResponse, error) <span class="cov0" title="0">{
        // 1. Validate agent belongs to organization
        var exists bool
        err := s.db.QueryRowContext(ctx,
                `SELECT EXISTS(SELECT 1 FROM agents WHERE id = $1 AND organization_id = $2)`,
                agentID, orgID,
        ).Scan(&amp;exists)

        if err != nil || !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("agent not found or unauthorized")
        }</span>

        <span class="cov0" title="0">response := &amp;domain.DetectionStatusResponse{
                AgentID:      agentID,
                SDKInstalled: false,
                DetectedMCPs: []domain.DetectedMCPSummary{},
        }

        // 2. Check SDK installation
        var sdk domain.SDKInstallation
        err = s.db.QueryRowContext(ctx, `
                SELECT sdk_version, auto_detect_enabled, last_heartbeat_at
                FROM sdk_installations
                WHERE agent_id = $1
        `, agentID).Scan(&amp;sdk.SDKVersion, &amp;sdk.AutoDetectEnabled, &amp;sdk.LastHeartbeatAt)

        if err == nil </span><span class="cov0" title="0">{
                response.SDKInstalled = true
                response.SDKVersion = sdk.SDKVersion
                response.AutoDetectEnabled = sdk.AutoDetectEnabled
                response.LastReportedAt = &amp;sdk.LastHeartbeatAt
        }</span>

        // 3. Get ALL connected MCPs from talks_to with their detection metadata
        // This query shows all servers in Connections tab, enriched with detection data
        <span class="cov0" title="0">rows, err := s.db.QueryContext(ctx, `
                WITH connected_mcps AS (
                        SELECT jsonb_array_elements_text(talks_to) as mcp_name
                        FROM agents WHERE id = $1
                )
                SELECT
                        t.mcp_name,
                        COALESCE(ARRAY_AGG(DISTINCT d.detection_method::text) FILTER (WHERE d.detection_method IS NOT NULL), ARRAY['manual']::text[]) as methods,
                        COALESCE(AVG(d.confidence_score), 0) as avg_confidence,
                        MIN(d.first_detected_at) as first_detected,
                        MAX(d.last_seen_at) as last_seen,
                        CASE WHEN COUNT(d.mcp_server_name) = 0 THEN true ELSE false END as is_manual
                FROM connected_mcps t
                LEFT JOIN agent_mcp_detections d
                        ON d.agent_id = $1 AND d.mcp_server_name = t.mcp_name
                GROUP BY t.mcp_name
                ORDER BY is_manual ASC, last_seen DESC NULLS LAST
        `, agentID)

        if err != nil </span><span class="cov0" title="0">{
                return response, nil // Return partial response
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var mcp domain.DetectedMCPSummary
                var methods []string
                var isManual bool
                var firstDetectedNull, lastSeenNull sql.NullTime

                err := rows.Scan(&amp;mcp.Name, pq.Array(&amp;methods), &amp;mcp.ConfidenceScore,
                        &amp;firstDetectedNull, &amp;lastSeenNull, &amp;isManual)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Handle nullable timestamps
                <span class="cov0" title="0">if firstDetectedNull.Valid </span><span class="cov0" title="0">{
                        mcp.FirstDetected = firstDetectedNull.Time
                }</span>
                <span class="cov0" title="0">if lastSeenNull.Valid </span><span class="cov0" title="0">{
                        mcp.LastSeen = lastSeenNull.Time
                }</span>

                // Convert methods to DetectionMethod type
                <span class="cov0" title="0">for _, m := range methods </span><span class="cov0" title="0">{
                        mcp.DetectedBy = append(mcp.DetectedBy, domain.DetectionMethod(m))
                }</span>

                // Boost confidence if multiple detection methods (only for auto-detected)
                <span class="cov0" title="0">if !isManual </span><span class="cov0" title="0">{
                        methodCount := len(mcp.DetectedBy)
                        if methodCount &gt;= 2 </span><span class="cov0" title="0">{
                                mcp.ConfidenceScore = min(99.0, mcp.ConfidenceScore+10)
                        }</span>
                        <span class="cov0" title="0">if methodCount &gt;= 3 </span><span class="cov0" title="0">{
                                mcp.ConfidenceScore = min(99.0, mcp.ConfidenceScore+20)
                        }</span>
                }

                <span class="cov0" title="0">response.DetectedMCPs = append(response.DetectedMCPs, mcp)</span>
        }

        <span class="cov0" title="0">return response, nil</span>
}

// ReportCapabilities processes agent capability detection reports from SDK
func (s *DetectionService) ReportCapabilities(
        ctx context.Context,
        agentID uuid.UUID,
        orgID uuid.UUID,
        req *domain.AgentCapabilityReport,
) (*domain.CapabilityReportResponse, error) <span class="cov0" title="0">{
        // 1. Validate agent belongs to organization
        var exists bool
        err := s.db.QueryRowContext(ctx,
                `SELECT EXISTS(SELECT 1 FROM agents WHERE id = $1 AND organization_id = $2)`,
                agentID, orgID,
        ).Scan(&amp;exists)

        if err != nil || !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("agent not found or unauthorized")
        }</span>

        // 2. Fetch full agent entity for comprehensive trust calculation
        <span class="cov0" title="0">agent, err := s.agentRepo.GetByID(agentID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch agent: %v", err)
        }</span>

        // 3. Calculate trust score using proper 9-factor algorithm (includes capability risk)
        // This replaces the naive addition/subtraction with comprehensive risk assessment
        <span class="cov0" title="0">trustScore, err := s.trustCalculator.Calculate(agent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to calculate trust score: %v", err)
        }</span>

        // Convert from 0-1 scale to 0-100 scale for storage
        <span class="cov0" title="0">newTrustScore := trustScore.Score * 100

        // 4. Convert capability report to JSON
        envJSON, _ := json.Marshal(req.Environment)
        aiModelsJSON, _ := json.Marshal(req.AIModels)
        capabilitiesJSON, _ := json.Marshal(req.Capabilities)
        riskAssessmentJSON, _ := json.Marshal(req.RiskAssessment)

        // 5. Store capability report in database
        _, err = s.db.ExecContext(ctx, `
                INSERT INTO agent_capability_reports (
                        agent_id, detected_at, environment, ai_models,
                        capabilities, risk_assessment, risk_level,
                        overall_risk_score, trust_score_impact
                ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
        `, agentID, req.DetectedAt, envJSON, aiModelsJSON,
                capabilitiesJSON, riskAssessmentJSON, req.RiskAssessment.RiskLevel,
                req.RiskAssessment.OverallRiskScore, req.RiskAssessment.TrustScoreImpact)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to store capability report: %v", err)
        }</span>

        // 6. Store trust score in trust_scores table for historical tracking
        <span class="cov0" title="0">factorsJSON, _ := json.Marshal(trustScore.Factors)
        _, err = s.db.ExecContext(ctx, `
                INSERT INTO trust_scores (
                        agent_id, score, factors, confidence, last_calculated
                ) VALUES ($1, $2, $3, $4, NOW())
        `, agentID, trustScore.Score, factorsJSON, trustScore.Confidence)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to store trust score: %v", err)
        }</span>

        // 7. Update agent trust score (keep agents table in sync)
        <span class="cov0" title="0">_, err = s.db.ExecContext(ctx, `
                UPDATE agents
                SET trust_score = $1, updated_at = NOW()
                WHERE id = $2
        `, newTrustScore, agentID)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update agent trust score: %v", err)
        }</span>

        // 8. Create security alerts for CRITICAL and HIGH severity issues
        <span class="cov0" title="0">for _, alert := range req.RiskAssessment.Alerts </span><span class="cov0" title="0">{
                if alert.Severity == "CRITICAL" || alert.Severity == "HIGH" </span><span class="cov0" title="0">{
                        // Store alert in database
                        s.db.ExecContext(ctx, `
                                INSERT INTO security_alerts (
                                        organization_id, agent_id, severity,
                                        alert_type, message, metadata, acknowledged
                                ) VALUES ($1, $2, $3, $4, $5, $6, FALSE)
                        `, orgID, agentID, alert.Severity, "capability_risk",
                                alert.Message, fmt.Sprintf(`{"capability": "%s", "recommendation": "%s"}`, alert.Capability, alert.Recommendation))
                }</span>
        }

        <span class="cov0" title="0">return &amp;domain.CapabilityReportResponse{
                Success:            true,
                AgentID:            agentID,
                RiskLevel:          req.RiskAssessment.RiskLevel,
                TrustScoreImpact:   req.RiskAssessment.TrustScoreImpact,
                NewTrustScore:      newTrustScore,
                SecurityAlertsCount: countHighSeverityAlerts(req.RiskAssessment.Alerts),
                Message:            fmt.Sprintf("Capability report processed. Risk: %s, Trust impact: %d", req.RiskAssessment.RiskLevel, req.RiskAssessment.TrustScoreImpact),
        }, nil</span>
}

// countHighSeverityAlerts counts CRITICAL and HIGH severity alerts
func countHighSeverityAlerts(alerts []domain.SecurityAlert) int <span class="cov0" title="0">{
        count := 0
        for _, alert := range alerts </span><span class="cov0" title="0">{
                if alert.Severity == "CRITICAL" || alert.Severity == "HIGH" </span><span class="cov0" title="0">{
                        count++
                }</span>
        }
        <span class="cov0" title="0">return count</span>
}

// Helper functions

func deduplicateSlice(slice []string) []string <span class="cov0" title="0">{
        seen := make(map[string]bool)
        result := []string{}

        for _, item := range slice </span><span class="cov0" title="0">{
                if !seen[item] </span><span class="cov0" title="0">{
                        seen[item] = true
                        result = append(result, item)
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package application

import (
        "fmt"
        "time"

        "github.com/google/uuid"
        "github.com/opena2a/identity/backend/internal/domain"
)

// Trust score penalty constants
const (
        // FirstViolationPenalty is the penalty for first-time drift violation (-5 points)
        FirstViolationPenalty = 5.0

        // RepeatedViolationPenalty is the penalty for repeated drift violations (-10 points)
        RepeatedViolationPenalty = 10.0

        // MinimumTrustScore is the lowest trust score allowed
        MinimumTrustScore = 0.0
)

// DriftDetectionService handles configuration drift detection for agents
type DriftDetectionService struct {
        agentRepo domain.AgentRepository
        alertRepo domain.AlertRepository
}

// NewDriftDetectionService creates a new drift detection service
func NewDriftDetectionService(agentRepo domain.AgentRepository, alertRepo domain.AlertRepository) *DriftDetectionService <span class="cov0" title="0">{
        return &amp;DriftDetectionService{
                agentRepo: agentRepo,
                alertRepo: alertRepo,
        }
}</span>

// DriftResult contains the results of drift detection
type DriftResult struct {
        DriftDetected     bool
        MCPServerDrift    []string
        CapabilityDrift   []string
        Alert             *domain.Alert
}

// DetectDrift checks if an agent's runtime configuration drifts from registered values
func (s *DriftDetectionService) DetectDrift(
        agentID uuid.UUID,
        currentMCPServers []string,
        currentCapabilities []string,
) (*DriftResult, error) <span class="cov0" title="0">{
        // 1. Get agent's registered configuration
        agent, err := s.agentRepo.GetByID(agentID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get agent: %w", err)
        }</span>

        // 2. Detect MCP server drift
        <span class="cov0" title="0">mcpDrift := detectArrayDrift(agent.TalksTo, currentMCPServers)

        // 3. Detect capability drift (if agent has registered capabilities)
        // Note: Capabilities are currently stored in separate table, so this is for future use
        capabilityDrift := []string{}

        // 4. If no drift detected, return early
        if len(mcpDrift) == 0 &amp;&amp; len(capabilityDrift) == 0 </span><span class="cov0" title="0">{
                return &amp;DriftResult{
                        DriftDetected:     false,
                        MCPServerDrift:    []string{},
                        CapabilityDrift:   []string{},
                }, nil
        }</span>

        // 5. Drift detected - create high-severity alert
        <span class="cov0" title="0">alert, err := s.createDriftAlert(agent, mcpDrift, capabilityDrift)
        if err != nil </span><span class="cov0" title="0">{
                // Log error but don't fail the drift detection
                fmt.Printf("Failed to create drift alert: %v\n", err)
        }</span>

        // 6. Apply trust score penalty
        <span class="cov0" title="0">if err := s.applyTrustScorePenalty(agent, mcpDrift, capabilityDrift); err != nil </span><span class="cov0" title="0">{
                // Log error but don't fail the drift detection
                fmt.Printf("Failed to apply trust score penalty: %v\n", err)
        }</span>

        <span class="cov0" title="0">return &amp;DriftResult{
                DriftDetected:     true,
                MCPServerDrift:    mcpDrift,
                CapabilityDrift:   capabilityDrift,
                Alert:             alert,
        }, nil</span>
}

// createDriftAlert creates a high-severity alert for configuration drift
func (s *DriftDetectionService) createDriftAlert(
        agent *domain.Agent,
        mcpDrift []string,
        capabilityDrift []string,
) (*domain.Alert, error) <span class="cov0" title="0">{
        // Build alert message
        message := fmt.Sprintf("Agent '%s' is deviating from registered configuration.", agent.Name)

        if len(mcpDrift) &gt; 0 </span><span class="cov0" title="0">{
                message += fmt.Sprintf("\n\n**Unauthorized MCP Server Communication:**\n")
                for _, mcp := range mcpDrift </span><span class="cov0" title="0">{
                        message += fmt.Sprintf("- `%s` (not registered)\n", mcp)
                }</span>
        }

        <span class="cov0" title="0">if len(capabilityDrift) &gt; 0 </span><span class="cov0" title="0">{
                message += fmt.Sprintf("\n\n**Undeclared Capability Usage:**\n")
                for _, cap := range capabilityDrift </span><span class="cov0" title="0">{
                        message += fmt.Sprintf("- `%s` (not declared)\n", cap)
                }</span>
        }

        <span class="cov0" title="0">message += "\n\n**Registered Configuration:**\n"
        if len(agent.TalksTo) &gt; 0 </span><span class="cov0" title="0">{
                message += "- MCP Servers: "
                for i, mcp := range agent.TalksTo </span><span class="cov0" title="0">{
                        if i &gt; 0 </span><span class="cov0" title="0">{
                                message += ", "
                        }</span>
                        <span class="cov0" title="0">message += fmt.Sprintf("`%s`", mcp)</span>
                }
                <span class="cov0" title="0">message += "\n"</span>
        } else<span class="cov0" title="0"> {
                message += "- MCP Servers: None registered\n"
        }</span>

        <span class="cov0" title="0">message += "\n**Recommended Actions:**\n"
        message += "1. Investigate why agent is using undeclared resources\n"
        message += "2. If legitimate, approve drift and update registration\n"
        message += "3. If suspicious, investigate for potential compromise\n"

        // Create alert
        alert := &amp;domain.Alert{
                ID:             uuid.New(),
                OrganizationID: agent.OrganizationID,
                AlertType:      domain.AlertTypeConfigurationDrift,
                Severity:       domain.AlertSeverityHigh,
                Title:          fmt.Sprintf("Configuration Drift Detected: %s", agent.Name),
                Description:    message,
                ResourceType:   "agent",
                ResourceID:     agent.ID,
                IsAcknowledged: false,
                CreatedAt:      time.Now(),
        }

        // Save alert
        if err := s.alertRepo.Create(alert); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create alert: %w", err)
        }</span>

        <span class="cov0" title="0">return alert, nil</span>
}

// applyTrustScorePenalty reduces agent trust score based on drift severity
func (s *DriftDetectionService) applyTrustScorePenalty(
        agent *domain.Agent,
        mcpDrift []string,
        capabilityDrift []string,
) error <span class="cov0" title="0">{
        // Calculate penalty based on violation history
        // capability_violation_count is incremented by UpdateTrustScore
        penalty := FirstViolationPenalty

        // If agent already has violations, use higher penalty
        if agent.CapabilityViolationCount &gt; 0 </span><span class="cov0" title="0">{
                penalty = RepeatedViolationPenalty
        }</span>

        // Calculate new trust score
        <span class="cov0" title="0">newScore := agent.TrustScore - penalty

        // Ensure score doesn't go below minimum
        if newScore &lt; MinimumTrustScore </span><span class="cov0" title="0">{
                newScore = MinimumTrustScore
        }</span>

        // Update agent trust score
        <span class="cov0" title="0">if err := s.agentRepo.UpdateTrustScore(agent.ID, newScore); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update trust score: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("✅ Applied trust score penalty to agent %s: %.2f -&gt; %.2f (-%0.f points)\n",
                agent.Name, agent.TrustScore, newScore, penalty)

        return nil</span>
}

// detectArrayDrift finds items in 'runtime' that are not in 'registered'
func detectArrayDrift(registered []string, runtime []string) []string <span class="cov0" title="0">{
        if len(runtime) == 0 </span><span class="cov0" title="0">{
                return []string{}
        }</span>

        // Create map of registered items for O(1) lookup
        <span class="cov0" title="0">registeredMap := make(map[string]bool)
        for _, item := range registered </span><span class="cov0" title="0">{
                registeredMap[item] = true
        }</span>

        // Find drift: items in runtime but not in registered
        <span class="cov0" title="0">drift := []string{}
        for _, item := range runtime </span><span class="cov0" title="0">{
                if !registeredMap[item] </span><span class="cov0" title="0">{
                        drift = append(drift, item)
                }</span>
        }

        <span class="cov0" title="0">return drift</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package application

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "github.com/google/uuid"
        "github.com/opena2a/identity/backend/internal/domain"
        "github.com/opena2a/identity/backend/internal/infrastructure/repository"
)

type MCPCapabilityService struct {
        capabilityRepo *repository.MCPServerCapabilityRepository
        mcpRepo        *repository.MCPServerRepository
}

func NewMCPCapabilityService(
        capabilityRepo *repository.MCPServerCapabilityRepository,
        mcpRepo *repository.MCPServerRepository,
) *MCPCapabilityService <span class="cov0" title="0">{
        return &amp;MCPCapabilityService{
                capabilityRepo: capabilityRepo,
                mcpRepo:        mcpRepo,
        }
}</span>

// DetectCapabilities detects and stores capabilities for an MCP server
// For MVP, this simulates capability detection
// In production, this would make an HTTP request to the MCP server's capabilities endpoint
func (s *MCPCapabilityService) DetectCapabilities(ctx context.Context, serverID uuid.UUID) error <span class="cov0" title="0">{
        // Get server details
        server, err := s.mcpRepo.GetByID(serverID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get MCP server: %w", err)
        }</span>

        // ✅ SIMULATED CAPABILITY DETECTION FOR MVP
        // In production, this would:
        // 1. Make HTTP request to server.URL + "/.well-known/mcp/capabilities"
        // 2. Parse the MCP protocol response
        // 3. Extract tools, resources, and prompts
        //
        // For now, we'll simulate by generating sample capabilities based on server URL

        <span class="cov0" title="0">capabilities := s.generateSampleCapabilities(server)

        // Store detected capabilities
        for _, cap := range capabilities </span><span class="cov0" title="0">{
                cap.MCPServerID = serverID
                cap.ID = uuid.New()
                cap.DetectedAt = time.Now().UTC()
                cap.IsActive = true

                if err := s.capabilityRepo.Create(cap); err != nil </span><span class="cov0" title="0">{
                        // Log error but continue with other capabilities
                        fmt.Printf("⚠️  Failed to store capability %s: %v\n", cap.Name, err)
                        continue</span>
                }

                <span class="cov0" title="0">fmt.Printf("✅ Detected %s capability: %s\n", cap.CapabilityType, cap.Name)</span>
        }

        <span class="cov0" title="0">fmt.Printf("✅ Successfully detected %d capabilities for MCP server %s\n", len(capabilities), server.Name)
        return nil</span>
}

// generateSampleCapabilities generates sample capabilities for testing
// In production, this would be replaced with actual MCP protocol communication
func (s *MCPCapabilityService) generateSampleCapabilities(server *domain.MCPServer) []*domain.MCPServerCapability <span class="cov0" title="0">{
        capabilities := []*domain.MCPServerCapability{}

        // Generate sample tools based on server URL patterns
        if containsAny(server.URL, []string{"openai", "gpt", "ai"}) </span><span class="cov0" title="0">{
                capabilities = append(capabilities,
                        s.createToolCapability("generate_text", "Generate text using AI models", map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "prompt":      map[string]string{"type": "string", "description": "Text prompt"},
                                        "max_tokens":  map[string]string{"type": "integer", "description": "Maximum tokens to generate"},
                                        "temperature": map[string]string{"type": "number", "description": "Sampling temperature"},
                                },
                                "required": []string{"prompt"},
                        }),
                        s.createToolCapability("analyze_sentiment", "Analyze sentiment of text", map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "text": map[string]string{"type": "string", "description": "Text to analyze"},
                                },
                                "required": []string{"text"},
                        }),
                )

                capabilities = append(capabilities,
                        s.createResourceCapability("models", "/models", "List available AI models", []string{"application/json"}),
                )

                capabilities = append(capabilities,
                        s.createPromptCapability("code_review", "Review code for best practices and potential issues", []string{"code", "language"}),
                )
        }</span>

        <span class="cov0" title="0">if containsAny(server.URL, []string{"github", "git", "code"}) </span><span class="cov0" title="0">{
                capabilities = append(capabilities,
                        s.createToolCapability("search_code", "Search code repositories", map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "query":      map[string]string{"type": "string", "description": "Search query"},
                                        "repository": map[string]string{"type": "string", "description": "Repository name"},
                                },
                                "required": []string{"query"},
                        }),
                        s.createToolCapability("create_pr", "Create a pull request", map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "title":  map[string]string{"type": "string", "description": "PR title"},
                                        "body":   map[string]string{"type": "string", "description": "PR description"},
                                        "branch": map[string]string{"type": "string", "description": "Source branch"},
                                },
                                "required": []string{"title", "branch"},
                        }),
                )

                capabilities = append(capabilities,
                        s.createResourceCapability("repositories", "/repos/{owner}/{repo}", "Access repository data", []string{"application/json"}),
                        s.createResourceCapability("issues", "/repos/{owner}/{repo}/issues", "Access issue data", []string{"application/json"}),
                )
        }</span>

        <span class="cov0" title="0">if containsAny(server.URL, []string{"database", "postgres", "mysql", "sql"}) </span><span class="cov0" title="0">{
                capabilities = append(capabilities,
                        s.createToolCapability("execute_query", "Execute SQL query", map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "query": map[string]string{"type": "string", "description": "SQL query to execute"},
                                },
                                "required": []string{"query"},
                        }),
                )

                capabilities = append(capabilities,
                        s.createResourceCapability("tables", "/tables", "List database tables", []string{"application/json"}),
                )
        }</span>

        // Default capabilities for any server
        <span class="cov0" title="0">if len(capabilities) == 0 </span><span class="cov0" title="0">{
                capabilities = append(capabilities,
                        s.createToolCapability("health_check", "Check server health status", map[string]interface{}{
                                "type":       "object",
                                "properties": map[string]interface{}{},
                        }),
                        s.createResourceCapability("server_info", "/info", "Get server information", []string{"application/json"}),
                )
        }</span>

        <span class="cov0" title="0">return capabilities</span>
}

func (s *MCPCapabilityService) createToolCapability(name, description string, schema interface{}) *domain.MCPServerCapability <span class="cov0" title="0">{
        schemaJSON, _ := json.Marshal(schema)
        return &amp;domain.MCPServerCapability{
                Name:             name,
                CapabilityType:   domain.MCPCapabilityTypeTool,
                Description:      description,
                CapabilitySchema: schemaJSON,
        }
}</span>

func (s *MCPCapabilityService) createResourceCapability(name, uri, description string, mimeTypes []string) *domain.MCPServerCapability <span class="cov0" title="0">{
        schema := map[string]interface{}{
                "uri":       uri,
                "mimeTypes": mimeTypes,
        }
        schemaJSON, _ := json.Marshal(schema)
        return &amp;domain.MCPServerCapability{
                Name:             name,
                CapabilityType:   domain.MCPCapabilityTypeResource,
                Description:      description,
                CapabilitySchema: schemaJSON,
        }
}</span>

func (s *MCPCapabilityService) createPromptCapability(name, description string, arguments []string) *domain.MCPServerCapability <span class="cov0" title="0">{
        schema := map[string]interface{}{
                "arguments": arguments,
        }
        schemaJSON, _ := json.Marshal(schema)
        return &amp;domain.MCPServerCapability{
                Name:             name,
                CapabilityType:   domain.MCPCapabilityTypePrompt,
                Description:      description,
                CapabilitySchema: schemaJSON,
        }
}</span>

// GetCapabilities retrieves all capabilities for an MCP server
func (s *MCPCapabilityService) GetCapabilities(ctx context.Context, serverID uuid.UUID) ([]*domain.MCPServerCapability, error) <span class="cov0" title="0">{
        return s.capabilityRepo.GetByServerID(serverID)
}</span>

// GetCapabilitiesByType retrieves capabilities by type
func (s *MCPCapabilityService) GetCapabilitiesByType(ctx context.Context, serverID uuid.UUID, capType domain.MCPCapabilityType) ([]*domain.MCPServerCapability, error) <span class="cov0" title="0">{
        return s.capabilityRepo.GetByServerIDAndType(serverID, capType)
}</span>

// Helper function to check if a string contains any of the given substrings
func containsAny(s string, substrings []string) bool <span class="cov0" title="0">{
        for _, substr := range substrings </span><span class="cov0" title="0">{
                if contains(s, substr) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func contains(s, substr string) bool <span class="cov0" title="0">{
        return len(s) &gt;= len(substr) &amp;&amp; (s == substr || findSubstring(s, substr))
}</span>

func findSubstring(s, substr string) bool <span class="cov0" title="0">{
        for i := 0; i &lt;= len(s)-len(substr); i++ </span><span class="cov0" title="0">{
                if s[i:i+len(substr)] == substr </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package application

import (
        "context"
        "fmt"
        "time"

        "github.com/google/uuid"
        "github.com/opena2a/identity/backend/internal/crypto"
        "github.com/opena2a/identity/backend/internal/domain"
        infracrypto "github.com/opena2a/identity/backend/internal/infrastructure/crypto"
        "github.com/opena2a/identity/backend/internal/infrastructure/repository"
)

type MCPService struct {
        mcpRepo               *repository.MCPServerRepository
        verificationEventRepo domain.VerificationEventRepository
        userRepo              *repository.UserRepository
        cryptoService         *infracrypto.ED25519Service
        keyVault              *crypto.KeyVault       // ✅ For secure private key storage
        capabilityService     *MCPCapabilityService  // ✅ For automatic capability detection
        // In-memory challenge storage (in production, use Redis)
        challenges map[string]ChallengeData
}

// ChallengeData stores challenge information
type ChallengeData struct {
        Challenge string
        ServerID  uuid.UUID
        CreatedAt time.Time
        ExpiresAt time.Time
}

func NewMCPService(mcpRepo *repository.MCPServerRepository, verificationEventRepo domain.VerificationEventRepository, userRepo *repository.UserRepository, keyVault *crypto.KeyVault, capabilityService *MCPCapabilityService) *MCPService <span class="cov0" title="0">{
        return &amp;MCPService{
                mcpRepo:               mcpRepo,
                verificationEventRepo: verificationEventRepo,
                userRepo:              userRepo,
                cryptoService:         infracrypto.NewED25519Service(),
                keyVault:              keyVault,
                capabilityService:     capabilityService,
                challenges:            make(map[string]ChallengeData),
        }
}</span>

// CreateMCPServerRequest represents the request to create an MCP server
type CreateMCPServerRequest struct {
        Name            string   `json:"name" validate:"required"`
        Description     string   `json:"description"`
        URL             string   `json:"url" validate:"required,url"`
        Version         string   `json:"version"`
        PublicKey       string   `json:"public_key"`
        VerificationURL string   `json:"verification_url"`
        Capabilities    []string `json:"capabilities"`
}

// UpdateMCPServerRequest represents the request to update an MCP server
type UpdateMCPServerRequest struct {
        Name            string   `json:"name"`
        Description     string   `json:"description"`
        URL             string   `json:"url"`
        Version         string   `json:"version"`
        PublicKey       string   `json:"public_key"`
        VerificationURL string   `json:"verification_url"`
        Capabilities    []string `json:"capabilities"`
}

// AddPublicKeyRequest represents the request to add a public key
type AddPublicKeyRequest struct {
        PublicKey string `json:"public_key" validate:"required"`
        KeyType   string `json:"key_type" validate:"required"` // e.g., "rsa", "ed25519"
}

// CreateMCPServer creates a new MCP server
func (s *MCPService) CreateMCPServer(ctx context.Context, req *CreateMCPServerRequest, orgID, userID uuid.UUID) (*domain.MCPServer, error) <span class="cov0" title="0">{
        // Check if MCP server with this URL already exists
        existing, _ := s.mcpRepo.GetByURL(req.URL)
        if existing != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("mcp server with this URL already exists")
        }</span>

        // ✅ AUTOMATIC KEY GENERATION - Zero effort for developers
        // If no public key provided, generate Ed25519 key pair automatically
        <span class="cov0" title="0">publicKey := req.PublicKey
        if publicKey == "" &amp;&amp; s.keyVault != nil </span><span class="cov0" title="0">{
                // Generate Ed25519 key pair automatically
                keyPair, err := crypto.GenerateEd25519KeyPair()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to generate cryptographic keys: %w", err)
                }</span>

                // Encode keys to base64 for storage
                <span class="cov0" title="0">encodedKeys := crypto.EncodeKeyPair(keyPair)
                publicKey = encodedKeys.PublicKeyBase64

                // Note: For MCP servers, we don't store the private key since the actual MCP server
                // will have its own private key. We just use this for initial verification testing.
                // In production, the real MCP server would sign challenges with its own private key.
                fmt.Printf("✅ Generated Ed25519 keys for MCP server %s\n", req.Name)</span>
        }

        <span class="cov0" title="0">server := &amp;domain.MCPServer{
                ID:              uuid.New(),
                OrganizationID:  orgID,
                Name:            req.Name,
                Description:     req.Description,
                URL:             req.URL,
                Version:         req.Version,
                PublicKey:       publicKey, // ✅ Auto-generated if not provided
                Status:          domain.MCPServerStatusPending,
                IsVerified:      false,
                VerificationURL: req.VerificationURL,
                Capabilities:    req.Capabilities,
                TrustScore:      0.0,
                CreatedBy:       userID,
        }

        if err := s.mcpRepo.Create(server); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // if server.PublicKey != "" {
        //        // Run verification asynchronously to avoid blocking the creation response
        //        go func() {
        //                // Use a background context for async operation
        //                bgCtx := context.Background()
        //                // Use localhost IP for system-initiated verification
        //                if err := s.VerifyMCPServer(bgCtx, server.ID, userID, "127.0.0.1"); err != nil {
        //                        fmt.Printf("⚠️  Automatic verification failed for MCP server %s: %v\n", server.Name, err)
        //                } else {
        //                        fmt.Printf("✅ Automatic verification succeeded for MCP server %s\n", server.Name)
        //                }
        //        }()
        // }
        // ✅ Manual verification required
        // MCP servers are created with status="pending" and is_verified=false
        // Admins must manually verify servers by clicking the "Verify" button in the UI
        // This ensures proper security review before servers are trusted

        <span class="cov0" title="0">return server, nil</span>
}

// GetMCPServer retrieves an MCP server by ID
func (s *MCPService) GetMCPServer(ctx context.Context, id uuid.UUID) (*domain.MCPServer, error) <span class="cov0" title="0">{
        return s.mcpRepo.GetByID(id)
}</span>

// ListMCPServers lists all MCP servers for an organization
func (s *MCPService) ListMCPServers(ctx context.Context, orgID uuid.UUID) ([]*domain.MCPServer, error) <span class="cov0" title="0">{
        return s.mcpRepo.GetByOrganization(orgID)
}</span>

// UpdateMCPServer updates an MCP server
func (s *MCPService) UpdateMCPServer(ctx context.Context, id uuid.UUID, req *UpdateMCPServerRequest) (*domain.MCPServer, error) <span class="cov0" title="0">{
        server, err := s.mcpRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Update fields
        <span class="cov0" title="0">if req.Name != "" </span><span class="cov0" title="0">{
                server.Name = req.Name
        }</span>
        <span class="cov0" title="0">if req.Description != "" </span><span class="cov0" title="0">{
                server.Description = req.Description
        }</span>
        <span class="cov0" title="0">if req.URL != "" </span><span class="cov0" title="0">{
                server.URL = req.URL
        }</span>
        <span class="cov0" title="0">if req.Version != "" </span><span class="cov0" title="0">{
                server.Version = req.Version
        }</span>
        <span class="cov0" title="0">if req.PublicKey != "" </span><span class="cov0" title="0">{
                server.PublicKey = req.PublicKey
        }</span>
        <span class="cov0" title="0">if req.VerificationURL != "" </span><span class="cov0" title="0">{
                server.VerificationURL = req.VerificationURL
        }</span>
        <span class="cov0" title="0">if len(req.Capabilities) &gt; 0 </span><span class="cov0" title="0">{
                server.Capabilities = req.Capabilities
        }</span>

        <span class="cov0" title="0">if err := s.mcpRepo.Update(server); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return server, nil</span>
}

// DeleteMCPServer deletes an MCP server
func (s *MCPService) DeleteMCPServer(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        return s.mcpRepo.Delete(id)
}</span>

// VerifyMCPServer performs cryptographic verification of an MCP server
func (s *MCPService) VerifyMCPServer(ctx context.Context, id uuid.UUID, userID uuid.UUID, userIP string) error <span class="cov0" title="0">{
        startTime := time.Now()

        server, err := s.mcpRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Fetch user information for audit trail
        <span class="cov0" title="0">var initiatorName *string
        if s.userRepo != nil </span><span class="cov0" title="0">{
                user, err := s.userRepo.GetByID(userID)
                if err == nil &amp;&amp; user != nil </span><span class="cov0" title="0">{
                        initiatorName = &amp;user.Email
                }</span>
        }

        // Cryptographic verification workflow:
        // 1. Check if server has a public key
        <span class="cov0" title="0">if server.PublicKey == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("server must have a public key for verification")
        }</span>

        // 2. Generate challenge
        <span class="cov0" title="0">_, err = s.GenerateVerificationChallenge(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate challenge: %w", err)
        }</span>

        // 3. In a real implementation, we would:
        //    - Send challenge to server's verification URL
        //    - Server signs challenge with its private key
        //    - Server returns signed challenge
        //    - We verify signature with stored public key
        //
        // For MVP, we'll simulate automatic success if public key exists
        // The infrastructure is in place for full implementation

        // Simulate challenge-response (for MVP)
        // In production, replace this with actual HTTP call to verification URL
        <span class="cov0" title="0">simulatedSuccess := server.PublicKey != ""

        var verificationStatus domain.VerificationEventStatus
        var verificationResult domain.VerificationResult
        var confidence float64
        var trustScore float64

        if simulatedSuccess </span><span class="cov0" title="0">{
                // Mark server as verified
                if err := s.mcpRepo.VerifyServer(ctx, id); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">now := time.Now()
                server.IsVerified = true
                server.Status = domain.MCPServerStatusVerified
                server.LastVerifiedAt = &amp;now
                server.TrustScore = 75.0 // Initial trust score for verified servers

                if err := s.mcpRepo.Update(server); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // ✅ AUTOMATIC CAPABILITY DETECTION
                // After successful verification, automatically detect MCP server capabilities
                <span class="cov0" title="0">if s.capabilityService != nil </span><span class="cov0" title="0">{
                        go func() </span><span class="cov0" title="0">{
                                // Run asynchronously to avoid blocking verification
                                bgCtx := context.Background()
                                if err := s.capabilityService.DetectCapabilities(bgCtx, id); err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("⚠️  Failed to detect capabilities for MCP server %s: %v\n", server.Name, err)
                                }</span>
                        }()
                }

                <span class="cov0" title="0">verificationStatus = domain.VerificationEventStatusSuccess
                verificationResult = domain.VerificationResultVerified
                confidence = 0.95
                trustScore = server.TrustScore</span>
        } else<span class="cov0" title="0"> {
                verificationStatus = domain.VerificationEventStatusFailed
                verificationResult = domain.VerificationResultDenied
                confidence = 0.0
                trustScore = 0.0
        }</span>

        // Create verification event for monitoring
        <span class="cov0" title="0">completedAt := time.Now()
        durationMs := int(completedAt.Sub(startTime).Milliseconds())

        mcpServerIDPtr := &amp;id
        mcpServerNamePtr := &amp;server.Name

        event := &amp;domain.VerificationEvent{
                ID:               uuid.New(),
                OrganizationID:   server.OrganizationID,
                MCPServerID:      mcpServerIDPtr,
                MCPServerName:    mcpServerNamePtr,
                Protocol:         domain.VerificationProtocolMCP,
                VerificationType: domain.VerificationTypeIdentity,
                Status:           verificationStatus,
                Result:           &amp;verificationResult,
                Confidence:       confidence,
                TrustScore:       trustScore,
                DurationMs:       durationMs,
                InitiatorType:    domain.InitiatorTypeUser,
                InitiatorID:      &amp;userID,
                InitiatorName:    initiatorName,
                InitiatorIP:      &amp;userIP,
                StartedAt:        startTime,
                CompletedAt:      &amp;completedAt,
                CreatedAt:        time.Now(),
        }

        // Store the verification event
        if s.verificationEventRepo != nil </span><span class="cov0" title="0">{
                if err := s.verificationEventRepo.Create(event); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("⚠️  Failed to create verification event: %v\n", err)
                }</span>
        }

        <span class="cov0" title="0">if !simulatedSuccess </span><span class="cov0" title="0">{
                return fmt.Errorf("verification failed")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// AddPublicKey adds a public key to an MCP server
func (s *MCPService) AddPublicKey(ctx context.Context, serverID uuid.UUID, req *AddPublicKeyRequest) error <span class="cov0" title="0">{
        // Verify server exists
        _, err := s.mcpRepo.GetByID(serverID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return s.mcpRepo.AddPublicKey(ctx, serverID, req.PublicKey, req.KeyType)</span>
}

// GetVerificationStatus retrieves the verification status of an MCP server
func (s *MCPService) GetVerificationStatus(ctx context.Context, id uuid.UUID) (*domain.MCPServerVerificationStatus, error) <span class="cov0" title="0">{
        return s.mcpRepo.GetVerificationStatus(id)
}</span>

// GenerateVerificationChallenge generates a challenge for server verification
func (s *MCPService) GenerateVerificationChallenge(ctx context.Context, serverID uuid.UUID) (string, error) <span class="cov0" title="0">{
        server, err := s.mcpRepo.GetByID(serverID)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Verify server has a public key
        <span class="cov0" title="0">if server.PublicKey == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("server must have a public key before verification")
        }</span>

        // Generate cryptographic challenge
        <span class="cov0" title="0">challenge, err := s.cryptoService.GenerateChallenge()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to generate challenge: %w", err)
        }</span>

        // Store challenge with expiration (5 minutes)
        <span class="cov0" title="0">now := time.Now()
        s.challenges[serverID.String()] = ChallengeData{
                Challenge: challenge,
                ServerID:  serverID,
                CreatedAt: now,
                ExpiresAt: now.Add(5 * time.Minute),
        }

        return challenge, nil</span>
}

// VerifyChallengeResponse verifies a signed challenge response
func (s *MCPService) VerifyChallengeResponse(ctx context.Context, serverID uuid.UUID, signedChallenge string) error <span class="cov0" title="0">{
        // Retrieve challenge
        challengeData, exists := s.challenges[serverID.String()]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("no challenge found for server")
        }</span>

        // Check if challenge has expired
        <span class="cov0" title="0">if time.Now().After(challengeData.ExpiresAt) </span><span class="cov0" title="0">{
                delete(s.challenges, serverID.String())
                return fmt.Errorf("challenge has expired")
        }</span>

        // Get server details
        <span class="cov0" title="0">server, err := s.mcpRepo.GetByID(serverID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Verify server has a public key
        <span class="cov0" title="0">if server.PublicKey == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("server does not have a public key")
        }</span>

        // Verify the signed challenge
        <span class="cov0" title="0">valid, err := s.cryptoService.Verify(server.PublicKey, []byte(challengeData.Challenge), signedChallenge)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to verify signature: %w", err)
        }</span>

        <span class="cov0" title="0">if !valid </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid signature")
        }</span>

        // Clean up challenge after successful verification
        <span class="cov0" title="0">delete(s.challenges, serverID.String())

        return nil</span>
}

// VerifyMCPAction verifies if an MCP server can perform an action
func (s *MCPService) VerifyMCPAction(
        ctx context.Context,
        mcpID uuid.UUID,
        actionType string,
        resource string,
        targetService string,
        metadata map[string]interface{},
) (allowed bool, reason string, auditID uuid.UUID, err error) <span class="cov0" title="0">{
        // 1. Fetch MCP server
        mcp, err := s.mcpRepo.GetByID(mcpID)
        if err != nil </span><span class="cov0" title="0">{
                return false, "MCP server not found", uuid.Nil, err
        }</span>

        // 2. Check MCP server status
        <span class="cov0" title="0">if mcp.Status != domain.MCPServerStatusVerified </span><span class="cov0" title="0">{
                return false, "MCP server not verified", uuid.Nil, nil
        }</span>

        // 3. Verify capabilities (simplified for now)
        <span class="cov0" title="0">allowed = mcp.IsVerified
        if allowed </span><span class="cov0" title="0">{
                reason = "MCP server is verified and authorized"
        }</span> else<span class="cov0" title="0"> {
                reason = "MCP server not verified"
        }</span>

        // 4. Audit log
        <span class="cov0" title="0">auditID = uuid.New()
        // TODO: Implement proper audit logging
        // This should create an audit log entry tracking:
        // - Which MCP server performed what action
        // - The target resource/service
        // - The decision (allowed/denied)
        // - Timestamp and metadata

        return allowed, reason, auditID, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package application

import (
        "context"
        "errors"
        "fmt"
        "os"
        "strings"
        "time"

        "github.com/google/uuid"
        "github.com/opena2a/identity/backend/internal/domain"
        "github.com/opena2a/identity/backend/internal/infrastructure/auth"
)

var (
        ErrRegistrationNotFound      = errors.New("registration request not found")
        ErrRegistrationNotPending    = errors.New("registration request is not pending")
        ErrUserAlreadyExists         = errors.New("user with this email already exists")
        ErrRegistrationRequestExists = errors.New("registration request with this email already exists")
)

// RegistrationRepository defines the interface for registration data persistence
type RegistrationRepository interface {
        // Registration requests
        CreateRegistrationRequest(ctx context.Context, req *domain.UserRegistrationRequest) error
        GetRegistrationRequest(ctx context.Context, id uuid.UUID) (*domain.UserRegistrationRequest, error)
        GetRegistrationRequestByEmail(ctx context.Context, email string) (*domain.UserRegistrationRequest, error)
        GetRegistrationRequestByEmailAnyStatus(ctx context.Context, email string) (*domain.UserRegistrationRequest, error)
        ListPendingRegistrationRequests(ctx context.Context, orgID uuid.UUID, limit, offset int) ([]*domain.UserRegistrationRequest, int, error)
        UpdateRegistrationRequest(ctx context.Context, req *domain.UserRegistrationRequest) error
}

// RegistrationService handles user registration and approval workflows
type RegistrationService struct {
        registrationRepo RegistrationRepository
        userRepo         domain.UserRepository
        auditService     *AuditService
        emailService     domain.EmailService
}

func NewRegistrationService(
        registrationRepo RegistrationRepository,
        userRepo domain.UserRepository,
        auditService *AuditService,
        emailService domain.EmailService,
) *RegistrationService <span class="cov0" title="0">{
        return &amp;RegistrationService{
                registrationRepo: registrationRepo,
                userRepo:         userRepo,
                auditService:     auditService,
                emailService:     emailService,
        }
}</span>

// CreateManualRegistrationRequest creates a registration request for email/password user registration
func (s *RegistrationService) CreateManualRegistrationRequest(
        ctx context.Context,
        email, firstName, lastName, password string,
) (*domain.UserRegistrationRequest, error) <span class="cov0" title="0">{
        // Check if user already exists
        existingUser, err := s.userRepo.GetByEmail(email)
        if err == nil &amp;&amp; existingUser != nil </span><span class="cov0" title="0">{
                return nil, ErrUserAlreadyExists
        }</span>

        // Check if a registration request already exists for this email
        <span class="cov0" title="0">existingRequest, err := s.registrationRepo.GetRegistrationRequestByEmail(ctx, email)
        if err == nil &amp;&amp; existingRequest != nil &amp;&amp; existingRequest.IsPending() </span><span class="cov0" title="0">{
                return nil, ErrRegistrationRequestExists
        }</span>

        // Hash and validate password
        <span class="cov0" title="0">passwordHasher := auth.NewPasswordHasher()
        if err := passwordHasher.ValidatePassword(password); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("password validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">hashedPassword, err := passwordHasher.HashPassword(password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to hash password: %w", err)
        }</span>

        // Create new manual registration request
        <span class="cov0" title="0">req := domain.NewUserRegistrationRequestManual(
                email,
                firstName,
                lastName,
                hashedPassword,
        )

        // Save registration request
        if err := s.registrationRepo.CreateRegistrationRequest(ctx, req); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create registration request: %w", err)
        }</span>

        // Send registration confirmation email
        <span class="cov0" title="0">if s.emailService != nil </span><span class="cov0" title="0">{
                frontendURL := os.Getenv("FRONTEND_URL")
                if frontendURL == "" </span><span class="cov0" title="0">{
                        frontendURL = "http://localhost:3000"
                }</span>

                <span class="cov0" title="0">supportEmail := os.Getenv("SUPPORT_EMAIL")
                if supportEmail == "" </span><span class="cov0" title="0">{
                        supportEmail = "support@opena2a.org"
                }</span>

                // Combine first and last name
                <span class="cov0" title="0">fullName := firstName
                if lastName != "" </span><span class="cov0" title="0">{
                        if fullName != "" </span><span class="cov0" title="0">{
                                fullName += " "
                        }</span>
                        <span class="cov0" title="0">fullName += lastName</span>
                }
                <span class="cov0" title="0">if fullName == "" </span><span class="cov0" title="0">{
                        fullName = email // Fallback to email if no name
                }</span>

                <span class="cov0" title="0">templateData := domain.EmailTemplateData{
                        UserName:     fullName,
                        UserEmail:    email,
                        DashboardURL: frontendURL,
                        SupportEmail: supportEmail,
                        Timestamp:    time.Now(),
                        CustomData: map[string]interface{}{
                                "FirstName": firstName,
                                "LastName":  lastName,
                        },
                }

                if err := s.emailService.SendTemplatedEmail(domain.TemplateWelcome, email, templateData); err != nil </span><span class="cov0" title="0">{
                        // Log error but don't fail the request (email is non-critical)
                        fmt.Printf("⚠️  Failed to send registration confirmation email to %s: %v\n", email, err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("✅ Sent registration confirmation email to %s\n", email)
                }</span>
        }

        <span class="cov0" title="0">return req, nil</span>
}

// CreateAccessRequest creates an access request without password (for request-access endpoint)
// This differs from CreateManualRegistrationRequest by not requiring a password
func (s *RegistrationService) CreateAccessRequest(
        ctx context.Context,
        email, firstName, lastName, reason string,
        organizationName *string,
) (*domain.UserRegistrationRequest, error) <span class="cov0" title="0">{
        // Check if user already exists
        existingUser, err := s.userRepo.GetByEmail(email)
        if err == nil &amp;&amp; existingUser != nil </span><span class="cov0" title="0">{
                return nil, ErrUserAlreadyExists
        }</span>

        // Check if a registration request already exists for this email
        <span class="cov0" title="0">existingRequest, err := s.registrationRepo.GetRegistrationRequestByEmail(ctx, email)
        if err == nil &amp;&amp; existingRequest != nil &amp;&amp; existingRequest.IsPending() </span><span class="cov0" title="0">{
                return nil, ErrRegistrationRequestExists
        }</span>

        // Create new access request (no password)
        <span class="cov0" title="0">now := time.Now()
        localProvider := domain.OAuthProviderLocal

        req := &amp;domain.UserRegistrationRequest{
                ID:                 uuid.New(),
                Email:              email,
                FirstName:          firstName,
                LastName:           lastName,
                PasswordHash:       nil, // No password for access requests
                OAuthProvider:      &amp;localProvider,
                OAuthUserID:        nil,
                Status:             domain.RegistrationStatusPending,
                RequestedAt:        now,
                OAuthEmailVerified: false,
                Metadata:           map[string]interface{}{
                        "reason": reason,
                },
                CreatedAt:          now,
                UpdatedAt:          now,
        }

        // Add organization name to metadata if provided
        if organizationName != nil &amp;&amp; *organizationName != "" </span><span class="cov0" title="0">{
                req.Metadata["organization_name"] = *organizationName
        }</span>

        // Save access request
        <span class="cov0" title="0">if err := s.registrationRepo.CreateRegistrationRequest(ctx, req); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create access request: %w", err)
        }</span>

        <span class="cov0" title="0">return req, nil</span>
}

// GetRegistrationRequest retrieves a registration request by ID
func (s *RegistrationService) GetRegistrationRequest(ctx context.Context, requestID uuid.UUID) (*domain.UserRegistrationRequest, error) <span class="cov0" title="0">{
        return s.registrationRepo.GetRegistrationRequest(ctx, requestID)
}</span>

// GetRegistrationRequestByEmail retrieves a registration request by email
func (s *RegistrationService) GetRegistrationRequestByEmail(ctx context.Context, email string) (*domain.UserRegistrationRequest, error) <span class="cov0" title="0">{
        // Use the any status method to find registration requests regardless of status
        return s.registrationRepo.GetRegistrationRequestByEmailAnyStatus(ctx, email)
}</span>

// ListPendingRegistrationRequests returns all pending registration requests for an organization
func (s *RegistrationService) ListPendingRegistrationRequests(
        ctx context.Context,
        orgID uuid.UUID,
        limit, offset int,
) ([]*domain.UserRegistrationRequest, int, error) <span class="cov0" title="0">{
        return s.registrationRepo.ListPendingRegistrationRequests(ctx, orgID, limit, offset)
}</span>

// ApproveRegistrationRequest approves a registration request and creates the user account
func (s *RegistrationService) ApproveRegistrationRequest(
        ctx context.Context,
        requestID uuid.UUID,
        reviewerID uuid.UUID,
        orgID uuid.UUID,
) (*domain.User, error) <span class="cov0" title="0">{
        // Get registration request
        req, err := s.registrationRepo.GetRegistrationRequest(ctx, requestID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrRegistrationNotFound
        }</span>

        <span class="cov0" title="0">if !req.IsPending() </span><span class="cov0" title="0">{
                return nil, ErrRegistrationNotPending
        }</span>

        // Approve request
        <span class="cov0" title="0">req.Approve(reviewerID)
        if err := s.registrationRepo.UpdateRegistrationRequest(ctx, req); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update registration request: %w", err)
        }</span>

        // Create user account
        // Combine first and last name for the Name field
        <span class="cov0" title="0">fullName := req.FirstName
        if req.LastName != "" </span><span class="cov0" title="0">{
                if fullName != "" </span><span class="cov0" title="0">{
                        fullName += " "
                }</span>
                <span class="cov0" title="0">fullName += req.LastName</span>
        }
        <span class="cov0" title="0">if fullName == "" </span><span class="cov0" title="0">{
                fullName = req.Email // Fallback to email if no name provided
        }</span>

        // Determine provider based on registration request type
        <span class="cov0" title="0">provider := "local" // Default to local for email/password
        providerID := req.Email // Use email as provider ID for local auth

        // If OAuth registration, use OAuth provider info
        if req.OAuthProvider != nil &amp;&amp; *req.OAuthProvider != "" </span><span class="cov0" title="0">{
                provider = string(*req.OAuthProvider) // Convert OAuthProvider enum to string
                if req.OAuthUserID != nil </span><span class="cov0" title="0">{
                        providerID = *req.OAuthUserID
                }</span>
        }

        <span class="cov0" title="0">user := &amp;domain.User{
                ID:             uuid.New(),
                OrganizationID: orgID,
                Email:          req.Email,
                Name:           fullName,
                Role:           domain.RoleViewer, // Default to viewer role for new users
                Provider:       provider,
                ProviderID:     providerID,
                PasswordHash:   req.PasswordHash,  // Will be set for email/password registrations
                ApprovedBy:     &amp;reviewerID,
                ApprovedAt:     &amp;time.Time{},
                Status:         domain.UserStatusActive, // Set user as active upon approval
                CreatedAt:      time.Now(),
                UpdatedAt:      time.Now(),
        }

        if req.PasswordHash != nil &amp;&amp; *req.PasswordHash != "" </span><span class="cov0" title="0">{
                fmt.Printf("✅ Approving user with password hash for email: %s\n", req.Email)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("⚠️  WARNING: Approving user without password hash - this should not happen for email/password registrations\n")
        }</span>

        // Set approval timestamp
        <span class="cov0" title="0">now := time.Now()
        user.ApprovedAt = &amp;now

        // Create user via repository
        if err := s.userRepo.Create(user); err != nil </span><span class="cov0" title="0">{
                // Log detailed error for debugging
                fmt.Printf("❌ CRITICAL ERROR: Failed to create user account after approval\n")
                fmt.Printf("   Email: %s\n", user.Email)
                fmt.Printf("   Organization ID: %s\n", user.OrganizationID)
                fmt.Printf("   Provider: %s\n", user.Provider)
                fmt.Printf("   ProviderID: %s\n", user.ProviderID)
                fmt.Printf("   Role: %s\n", user.Role)
                fmt.Printf("   Status: %s\n", user.Status)
                fmt.Printf("   Password Hash Present: %v\n", user.PasswordHash != nil &amp;&amp; *user.PasswordHash != "")
                fmt.Printf("   Error: %v\n", err)

                return nil, fmt.Errorf("failed to create user '%s' in database: %w", user.Email, err)
        }</span>

        // Success logging
        <span class="cov0" title="0">fmt.Printf("✅ Successfully created user account: %s (ID: %s)\n", user.Email, user.ID)

        // Log audit
        s.auditService.LogAction(
                ctx,
                orgID,
                reviewerID,
                domain.AuditActionCreate,
                "user",
                user.ID,
                "", // IP address
                "", // User agent
                map[string]interface{}{
                        "registration_id":     req.ID,
                        "registration_method": "email_password_registration",
                },
        )

        // Send approval email to user
        if s.emailService != nil </span><span class="cov0" title="0">{
                frontendURL := os.Getenv("FRONTEND_URL")
                if frontendURL == "" </span><span class="cov0" title="0">{
                        frontendURL = "http://localhost:3000"
                }</span>

                <span class="cov0" title="0">supportEmail := os.Getenv("SUPPORT_EMAIL")
                if supportEmail == "" </span><span class="cov0" title="0">{
                        supportEmail = "support@opena2a.org"
                }</span>

                <span class="cov0" title="0">loginURL := fmt.Sprintf("%s/auth/login", frontendURL)

                templateData := domain.EmailTemplateData{
                        UserName:     fullName,
                        UserEmail:    user.Email,
                        DashboardURL: frontendURL,
                        SupportEmail: supportEmail,
                        Timestamp:    now,
                        CustomData: map[string]interface{}{
                                "LoginURL": loginURL,
                                "Role":     string(user.Role),
                        },
                }

                if err := s.emailService.SendTemplatedEmail(domain.TemplateUserApproved, user.Email, templateData); err != nil </span><span class="cov0" title="0">{
                        // Log error but don't fail the request (email is non-critical)
                        fmt.Printf("⚠️  Failed to send approval email to %s: %v\n", user.Email, err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("✅ Sent approval email to %s\n", user.Email)
                }</span>
        }

        <span class="cov0" title="0">return user, nil</span>
}

// RejectRegistrationRequest rejects a registration request
func (s *RegistrationService) RejectRegistrationRequest(
        ctx context.Context,
        requestID uuid.UUID,
        reviewerID uuid.UUID,
        reason string,
) error <span class="cov0" title="0">{
        // Get registration request
        req, err := s.registrationRepo.GetRegistrationRequest(ctx, requestID)
        if err != nil </span><span class="cov0" title="0">{
                return ErrRegistrationNotFound
        }</span>

        <span class="cov0" title="0">if !req.IsPending() </span><span class="cov0" title="0">{
                return ErrRegistrationNotPending
        }</span>

        // Reject request
        <span class="cov0" title="0">req.Reject(reviewerID, reason)
        if err := s.registrationRepo.UpdateRegistrationRequest(ctx, req); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update registration request: %w", err)
        }</span>

        // TODO: Send rejection email to user

        <span class="cov0" title="0">return nil</span>
}

// RequestPasswordReset generates a password reset token for a user and sends a reset email
func (s *RegistrationService) RequestPasswordReset(
        ctx context.Context,
        email string,
) error <span class="cov0" title="0">{
        // Normalize email
        email = strings.ToLower(strings.TrimSpace(email))

        // Get user by email (fail silently for security)
        user, err := s.userRepo.GetByEmail(email)
        if err != nil || user == nil </span><span class="cov0" title="0">{
                // Don't reveal if user exists - always return success
                return nil
        }</span>

        // Check if user account is deactivated
        <span class="cov0" title="0">if user.Status == domain.UserStatusDeactivated || user.DeletedAt != nil </span><span class="cov0" title="0">{
                // Don't reveal if user is deactivated - always return success
                return nil
        }</span>

        // Generate password reset token (UUID format)
        <span class="cov0" title="0">resetToken := uuid.New().String()

        // Set expiration to 24 hours from now
        expiresAt := time.Now().Add(24 * time.Hour)

        // Update user with reset token and expiration
        user.PasswordResetToken = &amp;resetToken
        user.PasswordResetExpiresAt = &amp;expiresAt

        if err := s.userRepo.Update(user); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update user with reset token: %w", err)
        }</span>

        // Send password reset email using template
        <span class="cov0" title="0">if s.emailService != nil </span><span class="cov0" title="0">{
                frontendURL := os.Getenv("FRONTEND_URL")
                if frontendURL == "" </span><span class="cov0" title="0">{
                        frontendURL = "http://localhost:3000"
                }</span>

                <span class="cov0" title="0">supportEmail := os.Getenv("SUPPORT_EMAIL")
                if supportEmail == "" </span><span class="cov0" title="0">{
                        supportEmail = "support@opena2a.org"
                }</span>

                <span class="cov0" title="0">resetLink := fmt.Sprintf("%s/auth/reset-password?token=%s", frontendURL, resetToken)

                templateData := domain.EmailTemplateData{
                        UserName:     user.Name,
                        UserEmail:    user.Email,
                        DashboardURL: frontendURL,
                        SupportEmail: supportEmail,
                        Timestamp:    time.Now(),
                        ExpiresAt:    expiresAt,
                        CustomData: map[string]interface{}{
                                "ResetLink": resetLink,
                                "ExpiresIn": "24 hours",
                        },
                }

                if err := s.emailService.SendTemplatedEmail(domain.TemplatePasswordReset, user.Email, templateData); err != nil </span><span class="cov0" title="0">{
                        // Log error but don't fail the request (email is non-critical)
                        fmt.Printf("⚠️ Failed to send password reset email to %s: %v\n", email, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ResetPassword resets a user's password using a valid reset token
func (s *RegistrationService) ResetPassword(
        ctx context.Context,
        resetToken string,
        newPassword string,
        confirmPassword string,
) error <span class="cov0" title="0">{
        // Validate inputs
        if strings.TrimSpace(resetToken) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("reset token is required")
        }</span>
        <span class="cov0" title="0">if strings.TrimSpace(newPassword) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("new password is required")
        }</span>
        <span class="cov0" title="0">if newPassword != confirmPassword </span><span class="cov0" title="0">{
                return fmt.Errorf("passwords do not match")
        }</span>

        // Find user by reset token (automatically validates expiration)
        <span class="cov0" title="0">user, err := s.userRepo.GetByPasswordResetToken(resetToken)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid or expired reset token")
        }</span>

        // Validate password strength
        <span class="cov0" title="0">passwordHasher := auth.NewPasswordHasher()
        if err := passwordHasher.ValidatePassword(newPassword); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Hash new password
        <span class="cov0" title="0">hashedPassword, err := passwordHasher.HashPassword(newPassword)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to hash password: %w", err)
        }</span>

        // Update user password and clear reset token
        <span class="cov0" title="0">user.PasswordHash = &amp;hashedPassword
        user.PasswordResetToken = nil
        user.PasswordResetExpiresAt = nil
        user.ForcePasswordChange = false // Clear force password change if set
        user.UpdatedAt = time.Now()

        if err := s.userRepo.Update(user); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update password: %w", err)
        }</span>

        // Log audit event
        <span class="cov0" title="0">s.auditService.LogAction(
                ctx,
                user.OrganizationID,
                user.ID,
                domain.AuditActionUpdate,
                "user",
                user.ID,
                "", // IP address
                "", // User agent
                map[string]interface{}{
                        "action": "password_reset_completed",
                },
        )

        return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package application

import (
        "context"
        "fmt"

        "github.com/google/uuid"
        "github.com/opena2a/identity/backend/internal/domain"
)

// SDKTokenService handles SDK token business logic
type SDKTokenService struct {
        sdkTokenRepo domain.SDKTokenRepository
}

// NewSDKTokenService creates a new SDK token service
func NewSDKTokenService(sdkTokenRepo domain.SDKTokenRepository) *SDKTokenService <span class="cov0" title="0">{
        return &amp;SDKTokenService{
                sdkTokenRepo: sdkTokenRepo,
        }
}</span>

// GetUserTokens retrieves all SDK tokens for a user
func (s *SDKTokenService) GetUserTokens(ctx context.Context, userID uuid.UUID, includeRevoked bool) ([]*domain.SDKToken, error) <span class="cov0" title="0">{
        return s.sdkTokenRepo.GetByUserID(userID, includeRevoked)
}</span>

// GetOrganizationTokens retrieves all SDK tokens for an organization
func (s *SDKTokenService) GetOrganizationTokens(ctx context.Context, organizationID uuid.UUID, includeRevoked bool) ([]*domain.SDKToken, error) <span class="cov0" title="0">{
        return s.sdkTokenRepo.GetByOrganizationID(organizationID, includeRevoked)
}</span>

// RevokeToken revokes a specific SDK token
func (s *SDKTokenService) RevokeToken(ctx context.Context, tokenID uuid.UUID, userID uuid.UUID, reason string) error <span class="cov0" title="0">{
        // Get token to verify ownership
        token, err := s.sdkTokenRepo.GetByID(tokenID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("token not found: %w", err)
        }</span>

        // Verify user owns this token
        <span class="cov0" title="0">if token.UserID != userID </span><span class="cov0" title="0">{
                return fmt.Errorf("unauthorized: token belongs to different user")
        }</span>

        // Revoke token
        <span class="cov0" title="0">return s.sdkTokenRepo.Revoke(tokenID, reason)</span>
}

// RevokeByTokenHash revokes a token using its hash (for token rotation)
func (s *SDKTokenService) RevokeByTokenHash(ctx context.Context, tokenHash string, reason string) error <span class="cov0" title="0">{
        return s.sdkTokenRepo.RevokeByTokenHash(tokenHash, reason)
}</span>

// RevokeAllUserTokens revokes all SDK tokens for a user
func (s *SDKTokenService) RevokeAllUserTokens(ctx context.Context, userID uuid.UUID, reason string) error <span class="cov0" title="0">{
        return s.sdkTokenRepo.RevokeAllForUser(userID, reason)
}</span>

// GetActiveTokenCount returns count of active tokens for a user
func (s *SDKTokenService) GetActiveTokenCount(ctx context.Context, userID uuid.UUID) (int, error) <span class="cov0" title="0">{
        return s.sdkTokenRepo.GetActiveCount(userID)
}</span>

// RecordTokenUsage updates token usage statistics
func (s *SDKTokenService) RecordTokenUsage(ctx context.Context, tokenID string, ipAddress string) error <span class="cov0" title="0">{
        return s.sdkTokenRepo.RecordUsage(tokenID, ipAddress)
}</span>

// ValidateToken checks if a token is active (not revoked, not expired)
func (s *SDKTokenService) ValidateToken(ctx context.Context, tokenHash string) (*domain.SDKToken, error) <span class="cov0" title="0">{
        token, err := s.sdkTokenRepo.GetByTokenHash(tokenHash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("token not found: %w", err)
        }</span>

        <span class="cov0" title="0">if !token.IsActive() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("token is revoked or expired")
        }</span>

        <span class="cov0" title="0">return token, nil</span>
}

// CleanupExpiredTokens removes expired tokens (for scheduled jobs)
func (s *SDKTokenService) CleanupExpiredTokens(ctx context.Context) error <span class="cov0" title="0">{
        return s.sdkTokenRepo.DeleteExpired()
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package application

import (
        "context"
        "fmt"
        "strings"

        "github.com/google/uuid"
        "github.com/opena2a/identity/backend/internal/domain"
)

// SecurityPolicyService handles security policy evaluation and management
type SecurityPolicyService struct {
        policyRepo domain.SecurityPolicyRepository
        alertRepo  domain.AlertRepository
}

// NewSecurityPolicyService creates a new security policy service
func NewSecurityPolicyService(
        policyRepo domain.SecurityPolicyRepository,
        alertRepo domain.AlertRepository,
) *SecurityPolicyService <span class="cov0" title="0">{
        return &amp;SecurityPolicyService{
                policyRepo: policyRepo,
                alertRepo:  alertRepo,
        }
}</span>

// EvaluateCapabilityViolation evaluates security policies for capability violations
// Returns enforcement decision and whether to create an alert
func (s *SecurityPolicyService) EvaluateCapabilityViolation(
        ctx context.Context,
        agent *domain.Agent,
        actionType string,
        resource string,
        auditID uuid.UUID,
) (shouldBlock bool, shouldAlert bool, policyName string, err error) <span class="cov0" title="0">{
        // 1. Get active capability_violation policies for this organization
        policies, err := s.policyRepo.GetByType(agent.OrganizationID, domain.PolicyTypeCapabilityViolation)
        if err != nil </span><span class="cov0" title="0">{
                return false, false, "", fmt.Errorf("failed to fetch policies: %w", err)
        }</span>

        // 2. If no policies configured, use safe defaults (block + alert)
        <span class="cov0" title="0">if len(policies) == 0 </span><span class="cov0" title="0">{
                fmt.Printf("⚠️  No security policies configured for org %s, using default: block + alert\n", agent.OrganizationID)
                return true, true, "default_policy", nil
        }</span>

        // 3. Evaluate policies by priority (highest first)
        <span class="cov0" title="0">for _, policy := range policies </span><span class="cov0" title="0">{
                // Check if policy applies to this agent
                if !s.policyAppliesToAgent(policy, agent) </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Policy matches - return enforcement action
                <span class="cov0" title="0">fmt.Printf("✅ Security Policy '%s' triggered for agent %s (action: %s)\n",
                        policy.Name, agent.Name, policy.EnforcementAction)

                switch policy.EnforcementAction </span>{
                case domain.EnforcementBlockAndAlert:<span class="cov0" title="0">
                        return true, true, policy.Name, nil</span>
                case domain.EnforcementAlertOnly:<span class="cov0" title="0">
                        return false, true, policy.Name, nil</span>
                case domain.EnforcementAllow:<span class="cov0" title="0">
                        return false, false, policy.Name, nil</span>
                default:<span class="cov0" title="0">
                        // Unknown enforcement action - use safe default
                        return true, true, policy.Name, nil</span>
                }
        }

        // 4. No matching policy found - use safe default (block + alert)
        <span class="cov0" title="0">fmt.Printf("⚠️  No matching security policy for agent %s, using default: block + alert\n", agent.Name)
        return true, true, "default_policy", nil</span>
}

// policyAppliesToAgent checks if a policy applies to a specific agent
func (s *SecurityPolicyService) policyAppliesToAgent(policy *domain.SecurityPolicy, agent *domain.Agent) bool <span class="cov0" title="0">{
        appliesTo := policy.AppliesTo

        // Apply to all agents
        if appliesTo == "all" </span><span class="cov0" title="0">{
                return true
        }</span>

        // Apply to specific agent ID
        <span class="cov0" title="0">if strings.HasPrefix(appliesTo, "agent_id:") </span><span class="cov0" title="0">{
                targetID := strings.TrimPrefix(appliesTo, "agent_id:")
                return targetID == agent.ID.String()
        }</span>

        // Apply to specific agent type
        <span class="cov0" title="0">if strings.HasPrefix(appliesTo, "agent_type:") </span><span class="cov0" title="0">{
                targetType := strings.TrimPrefix(appliesTo, "agent_type:")
                return targetType == string(agent.AgentType)
        }</span>

        // Apply to agents with trust score below threshold
        <span class="cov0" title="0">if strings.HasPrefix(appliesTo, "trust_score_below:") </span><span class="cov0" title="0">{
                var threshold float64
                fmt.Sscanf(appliesTo, "trust_score_below:%f", &amp;threshold)
                return agent.TrustScore &lt; threshold
        }</span>

        // Default: apply to all
        <span class="cov0" title="0">return true</span>
}

// CreateDefaultPolicies creates default security policies for a new organization
func (s *SecurityPolicyService) CreateDefaultPolicies(ctx context.Context, orgID, userID uuid.UUID) error <span class="cov0" title="0">{
        // Default Policy 1: Alert on Capability Violations (HIGH priority)
        // NOTE: Default is alert-only. Admins can enable blocking with explicit confirmation.
        capabilityViolationPolicy := &amp;domain.SecurityPolicy{
                OrganizationID:    orgID,
                Name:              "Monitor Capability Violations",
                Description:       "Generate alerts on any capability violations (e.g., EchoLeak attacks). This monitors unauthorized actions that exceed an agent's registered capabilities. Admins can enable blocking mode to prevent these actions.",
                PolicyType:        domain.PolicyTypeCapabilityViolation,
                EnforcementAction: domain.EnforcementAlertOnly,
                SeverityThreshold: domain.AlertSeverityHigh,
                Rules: map[string]interface{}{
                        "attack_patterns": []string{"echoleak", "bulk_access", "data_exfiltration"},
                },
                AppliesTo: "all",
                IsEnabled: true,
                Priority:  1000, // Highest priority
                CreatedBy: userID,
        }

        if err := s.policyRepo.Create(capabilityViolationPolicy); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create capability violation policy: %w", err)
        }</span>

        // Default Policy 2: Alert Only for Low Trust Score Agents
        <span class="cov0" title="0">lowTrustPolicy := &amp;domain.SecurityPolicy{
                OrganizationID:    orgID,
                Name:              "Monitor Low Trust Score Agents",
                Description:       "Generate alerts for agents with trust scores below 0.3 (30%). Does not block actions, but provides visibility into potentially risky agents.",
                PolicyType:        domain.PolicyTypeTrustScoreLow,
                EnforcementAction: domain.EnforcementAlertOnly,
                SeverityThreshold: domain.AlertSeverityWarning,
                Rules: map[string]interface{}{
                        "trust_threshold": 0.3,
                },
                AppliesTo: "trust_score_below:0.3",
                IsEnabled: true,
                Priority:  500, // Medium priority
                CreatedBy: userID,
        }

        if err := s.policyRepo.Create(lowTrustPolicy); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create low trust policy: %w", err)
        }</span>

        // Default Policy 3: Alert on Data Exfiltration Attempts
        // NOTE: Default is alert-only. Admins can enable blocking with explicit confirmation.
        <span class="cov0" title="0">dataExfiltrationPolicy := &amp;domain.SecurityPolicy{
                OrganizationID:    orgID,
                Name:              "Monitor Data Exfiltration",
                Description:       "Generate alerts on suspected data exfiltration attempts (e.g., external URL fetching, bulk data access). This monitors potential data leakage. Admins can enable blocking mode to prevent these actions.",
                PolicyType:        domain.PolicyTypeDataExfiltration,
                EnforcementAction: domain.EnforcementAlertOnly,
                SeverityThreshold: domain.AlertSeverityCritical,
                Rules: map[string]interface{}{
                        "patterns": []string{"fetch_external_url", "bulk_export", "mass_download"},
                },
                AppliesTo: "all",
                IsEnabled: true,
                Priority:  900, // High priority
                CreatedBy: userID,
        }

        if err := s.policyRepo.Create(dataExfiltrationPolicy); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create data exfiltration policy: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("✅ Created 3 default security policies for organization %s\n", orgID)
        return nil</span>
}

// ListPolicies retrieves all security policies for an organization
func (s *SecurityPolicyService) ListPolicies(ctx context.Context, orgID uuid.UUID) ([]*domain.SecurityPolicy, error) <span class="cov0" title="0">{
        return s.policyRepo.GetByOrganization(orgID)
}</span>

// GetPolicy retrieves a security policy by ID
func (s *SecurityPolicyService) GetPolicy(ctx context.Context, id uuid.UUID) (*domain.SecurityPolicy, error) <span class="cov0" title="0">{
        return s.policyRepo.GetByID(id)
}</span>

// CreatePolicy creates a new security policy
func (s *SecurityPolicyService) CreatePolicy(ctx context.Context, policy *domain.SecurityPolicy) error <span class="cov0" title="0">{
        return s.policyRepo.Create(policy)
}</span>

// UpdatePolicy updates a security policy
func (s *SecurityPolicyService) UpdatePolicy(ctx context.Context, policy *domain.SecurityPolicy) error <span class="cov0" title="0">{
        return s.policyRepo.Update(policy)
}</span>

// DeletePolicy deletes a security policy
func (s *SecurityPolicyService) DeletePolicy(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        return s.policyRepo.Delete(id)
}</span>

// EnablePolicy enables a security policy
func (s *SecurityPolicyService) EnablePolicy(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        policy, err := s.policyRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">policy.IsEnabled = true
        return s.policyRepo.Update(policy)</span>
}

// DisablePolicy disables a security policy
func (s *SecurityPolicyService) DisablePolicy(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        policy, err := s.policyRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">policy.IsEnabled = false
        return s.policyRepo.Update(policy)</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package application

import (
        "context"
        "time"

        "github.com/google/uuid"
        "github.com/opena2a/identity/backend/internal/domain"
        "github.com/opena2a/identity/backend/internal/infrastructure/repository"
)

type SecurityService struct {
        securityRepo *repository.SecurityRepository
        agentRepo    *repository.AgentRepository
        alertRepo    domain.AlertRepository  // ✅ NEW: For converting alerts to threats
}

func NewSecurityService(
        securityRepo *repository.SecurityRepository,
        agentRepo *repository.AgentRepository,
        alertRepo domain.AlertRepository,
) *SecurityService <span class="cov0" title="0">{
        return &amp;SecurityService{
                securityRepo: securityRepo,
                agentRepo:    agentRepo,
                alertRepo:    alertRepo,
        }
}</span>

// GetThreats retrieves security threats
// ✅ ENTERPRISE SOLUTION: Convert real alerts to threats (NO MOCK DATA!)
func (s *SecurityService) GetThreats(ctx context.Context, orgID uuid.UUID, limit, offset int) ([]*domain.Threat, error) <span class="cov0" title="0">{
        // Fetch real alerts from database
        alerts, err := s.alertRepo.GetByOrganization(orgID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Convert alerts to threats for display in Security Dashboard
        <span class="cov0" title="0">threats := make([]*domain.Threat, 0, len(alerts))
        for _, alert := range alerts </span><span class="cov0" title="0">{
                // Map alert type to threat type
                threatType := mapAlertTypeToThreatType(alert.AlertType)

                // Create target name (short ID for display)
                targetName := alert.ResourceID.String()[:8] + "..."

                // Create threat from alert
                threat := &amp;domain.Threat{
                        ID:             alert.ID,
                        OrganizationID: alert.OrganizationID,
                        ThreatType:     domain.ThreatType(threatType),
                        Severity:       alert.Severity,
                        Title:          alert.Title,
                        Description:    alert.Description,
                        Source:         alert.ResourceID.String(),
                        TargetType:     alert.ResourceType,
                        TargetID:       alert.ResourceID,
                        TargetName:     &amp;targetName, // Pointer to short ID for display
                        IsBlocked:      false,        // Alerts don't have blocked status
                        CreatedAt:      alert.CreatedAt,
                        ResolvedAt:     alert.AcknowledgedAt, // Map acknowledged_at to resolved_at
                }

                threats = append(threats, threat)
        }</span>

        <span class="cov0" title="0">return threats, nil</span>
}

// mapAlertTypeToThreatType converts alert types to threat types for display
func mapAlertTypeToThreatType(alertType domain.AlertType) string <span class="cov0" title="0">{
        switch alertType </span>{
        case domain.AlertSecurityBreach:<span class="cov0" title="0">
                return "malicious_agent"</span>
        case domain.AlertCertificateExpiring:<span class="cov0" title="0">
                return "certificate_expiry"</span>
        case domain.AlertAPIKeyExpiring:<span class="cov0" title="0">
                return "credential_leak"</span>
        case domain.AlertTrustScoreLow:<span class="cov0" title="0">
                return "suspicious_activity"</span>
        case domain.AlertTypeConfigurationDrift:<span class="cov0" title="0">
                return "configuration_drift"</span>
        default:<span class="cov0" title="0">
                return "suspicious_activity"</span>
        }
}

// GetAnomalies retrieves detected anomalies
func (s *SecurityService) GetAnomalies(ctx context.Context, orgID uuid.UUID, limit, offset int) ([]*domain.Anomaly, error) <span class="cov0" title="0">{
        return s.securityRepo.GetAnomalies(orgID, limit, offset)
}</span>

// GetSecurityMetrics retrieves overall security metrics
func (s *SecurityService) GetSecurityMetrics(ctx context.Context, orgID uuid.UUID) (*domain.SecurityMetrics, error) <span class="cov0" title="0">{
        return s.securityRepo.GetSecurityMetrics(orgID)
}</span>

// RunSecurityScan initiates a security scan
func (s *SecurityService) RunSecurityScan(ctx context.Context, orgID uuid.UUID, scanType string) (*domain.SecurityScanResult, error) <span class="cov0" title="0">{
        scan := &amp;domain.SecurityScanResult{
                ScanID:         uuid.New(),
                OrganizationID: orgID,
                ScanType:       scanType,
                Status:         "running",
                StartedAt:      time.Now().UTC(),
        }

        // Create scan record
        if err := s.securityRepo.CreateSecurityScan(scan); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Perform scan asynchronously (in production, this would be a background job)
        <span class="cov0" title="0">go s.performSecurityScan(scan)

        return scan, nil</span>
}

// performSecurityScan performs the actual security scanning
func (s *SecurityService) performSecurityScan(scan *domain.SecurityScanResult) <span class="cov0" title="0">{
        // TODO: Implement actual security scanning logic
        // For now, we'll simulate a scan

        // Get all agents for the organization
        agents, _ := s.agentRepo.GetByOrganization(scan.OrganizationID)

        threatsFound := 0
        anomaliesFound := 0
        vulnerabilitiesFound := 0

        // Check for low trust scores (potential threats)
        for _, agent := range agents </span><span class="cov0" title="0">{
                if agent.TrustScore &lt; 50 </span><span class="cov0" title="0">{
                        threatsFound++
                }</span>
                <span class="cov0" title="0">if agent.TrustScore &lt; 70 &amp;&amp; agent.TrustScore &gt;= 50 </span><span class="cov0" title="0">{
                        anomaliesFound++
                }</span>
        }

        // Calculate security score
        <span class="cov0" title="0">securityScore := 100.0
        if len(agents) &gt; 0 </span><span class="cov0" title="0">{
                avgTrustScore := 0.0
                for _, agent := range agents </span><span class="cov0" title="0">{
                        avgTrustScore += agent.TrustScore
                }</span>
                <span class="cov0" title="0">avgTrustScore /= float64(len(agents))
                securityScore = avgTrustScore</span>
        }

        // Update scan results
        <span class="cov0" title="0">scan.ThreatsFound = threatsFound
        scan.AnomaliesFound = anomaliesFound
        scan.VulnerabilitiesFound = vulnerabilitiesFound
        scan.SecurityScore = securityScore
        scan.Status = "completed"
        completedAt := time.Now().UTC()
        scan.CompletedAt = &amp;completedAt</span>
}

// GetSecurityScan retrieves a security scan by ID
func (s *SecurityService) GetSecurityScan(ctx context.Context, scanID uuid.UUID) (*domain.SecurityScanResult, error) <span class="cov0" title="0">{
        return s.securityRepo.GetSecurityScan(scanID)
}</span>

// GetIncidents retrieves security incidents
func (s *SecurityService) GetIncidents(ctx context.Context, orgID uuid.UUID, status domain.IncidentStatus, limit, offset int) ([]*domain.SecurityIncident, error) <span class="cov0" title="0">{
        return s.securityRepo.GetIncidents(orgID, status, limit, offset)
}</span>

// ResolveIncident marks a security incident as resolved
func (s *SecurityService) ResolveIncident(ctx context.Context, incidentID uuid.UUID, resolvedBy uuid.UUID, notes string) error <span class="cov0" title="0">{
        return s.securityRepo.UpdateIncidentStatus(incidentID, domain.IncidentStatusResolved, &amp;resolvedBy, notes)
}</span>

// CreateThreat creates a new security threat
func (s *SecurityService) CreateThreat(ctx context.Context, threat *domain.Threat) error <span class="cov0" title="0">{
        threat.ID = uuid.New()
        threat.CreatedAt = time.Now().UTC()
        return s.securityRepo.CreateThreat(threat)
}</span>

// CreateAnomaly creates a new anomaly
func (s *SecurityService) CreateAnomaly(ctx context.Context, anomaly *domain.Anomaly) error <span class="cov0" title="0">{
        anomaly.ID = uuid.New()
        anomaly.CreatedAt = time.Now().UTC()
        return s.securityRepo.CreateAnomaly(anomaly)
}</span>

// CreateIncident creates a new security incident
func (s *SecurityService) CreateIncident(ctx context.Context, incident *domain.SecurityIncident) error <span class="cov0" title="0">{
        incident.ID = uuid.New()
        incident.CreatedAt = time.Now().UTC()
        incident.UpdatedAt = time.Now().UTC()
        return s.securityRepo.CreateIncident(incident)
}</span>

// BlockThreat blocks a security threat
func (s *SecurityService) BlockThreat(ctx context.Context, threatID uuid.UUID) error <span class="cov0" title="0">{
        return s.securityRepo.BlockThreat(threatID)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package application

import (
        "context"
        "fmt"
        "strings"

        "github.com/google/uuid"
        "github.com/opena2a/identity/backend/internal/domain"
)

// TagService handles business logic for tag management
type TagService struct {
        tagRepo   domain.TagRepository
        agentRepo domain.AgentRepository
        mcpRepo   domain.MCPServerRepository
}

// NewTagService creates a new tag service instance
func NewTagService(
        tagRepo domain.TagRepository,
        agentRepo domain.AgentRepository,
        mcpRepo domain.MCPServerRepository,
) *TagService <span class="cov0" title="0">{
        return &amp;TagService{
                tagRepo:   tagRepo,
                agentRepo: agentRepo,
                mcpRepo:   mcpRepo,
        }
}</span>

// CreateTagInput represents input for creating a new tag
type CreateTagInput struct {
        OrganizationID uuid.UUID
        Key            string
        Value          string
        Category       domain.TagCategory
        Description    string
        Color          string
        CreatedBy      uuid.UUID
}

// CreateTag creates a new tag with validation
func (s *TagService) CreateTag(ctx context.Context, input CreateTagInput) (*domain.Tag, error) <span class="cov0" title="0">{
        // Validate input
        if err := s.validateTagInput(input); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create tag
        <span class="cov0" title="0">tag := &amp;domain.Tag{
                OrganizationID: input.OrganizationID,
                Key:            strings.TrimSpace(input.Key),
                Value:          strings.TrimSpace(input.Value),
                Category:       input.Category,
                Description:    input.Description,
                Color:          input.Color,
                CreatedBy:      input.CreatedBy,
        }

        if err := s.tagRepo.Create(ctx, tag); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create tag: %w", err)
        }</span>

        <span class="cov0" title="0">return tag, nil</span>
}

// GetTagsByOrganization retrieves all tags for an organization
func (s *TagService) GetTagsByOrganization(ctx context.Context, orgID uuid.UUID, category *domain.TagCategory) ([]*domain.Tag, error) <span class="cov0" title="0">{
        tags, err := s.tagRepo.List(ctx, orgID, category)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get tags: %w", err)
        }</span>
        <span class="cov0" title="0">return tags, nil</span>
}

// DeleteTag deletes a tag (only if not in use)
func (s *TagService) DeleteTag(ctx context.Context, tagID uuid.UUID) error <span class="cov0" title="0">{
        if err := s.tagRepo.Delete(ctx, tagID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete tag: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// AddTagsToAgent adds tags to an agent with smart suggestions
func (s *TagService) AddTagsToAgent(ctx context.Context, agentID uuid.UUID, tagIDs []uuid.UUID, appliedBy uuid.UUID) error <span class="cov0" title="0">{
        // Verify agent exists
        agent, err := s.agentRepo.GetByID(agentID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("agent not found: %w", err)
        }</span>

        // Verify all tags exist and belong to same organization
        <span class="cov0" title="0">for _, tagID := range tagIDs </span><span class="cov0" title="0">{
                tag, err := s.tagRepo.GetByID(ctx, tagID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("tag %s not found: %w", tagID, err)
                }</span>
                <span class="cov0" title="0">if tag.OrganizationID != agent.OrganizationID </span><span class="cov0" title="0">{
                        return fmt.Errorf("tag %s does not belong to agent's organization", tagID)
                }</span>
        }

        // Add tags (database trigger enforces Community Edition 3-tag limit)
        <span class="cov0" title="0">if err := s.tagRepo.AddTagsToAgent(ctx, agentID, tagIDs); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add tags to agent: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RemoveTagFromAgent removes a tag from an agent
func (s *TagService) RemoveTagFromAgent(ctx context.Context, agentID, tagID uuid.UUID) error <span class="cov0" title="0">{
        if err := s.tagRepo.RemoveTagFromAgent(ctx, agentID, tagID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove tag from agent: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetAgentTags retrieves all tags for an agent
func (s *TagService) GetAgentTags(ctx context.Context, agentID uuid.UUID) ([]*domain.Tag, error) <span class="cov0" title="0">{
        tags, err := s.tagRepo.GetAgentTags(ctx, agentID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get agent tags: %w", err)
        }</span>
        <span class="cov0" title="0">return tags, nil</span>
}

// AddTagsToMCPServer adds tags to an MCP server with smart suggestions
func (s *TagService) AddTagsToMCPServer(ctx context.Context, mcpServerID uuid.UUID, tagIDs []uuid.UUID, appliedBy uuid.UUID) error <span class="cov0" title="0">{
        // Verify MCP server exists
        mcpServer, err := s.mcpRepo.GetByID(mcpServerID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("mcp server not found: %w", err)
        }</span>

        // Verify all tags exist and belong to same organization
        <span class="cov0" title="0">for _, tagID := range tagIDs </span><span class="cov0" title="0">{
                tag, err := s.tagRepo.GetByID(ctx, tagID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("tag %s not found: %w", tagID, err)
                }</span>
                <span class="cov0" title="0">if tag.OrganizationID != mcpServer.OrganizationID </span><span class="cov0" title="0">{
                        return fmt.Errorf("tag %s does not belong to mcp server's organization", tagID)
                }</span>
        }

        // Add tags (database trigger enforces Community Edition 3-tag limit)
        <span class="cov0" title="0">if err := s.tagRepo.AddTagsToMCPServer(ctx, mcpServerID, tagIDs); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add tags to mcp server: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RemoveTagFromMCPServer removes a tag from an MCP server
func (s *TagService) RemoveTagFromMCPServer(ctx context.Context, mcpServerID, tagID uuid.UUID) error <span class="cov0" title="0">{
        if err := s.tagRepo.RemoveTagFromMCPServer(ctx, mcpServerID, tagID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove tag from mcp server: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetMCPServerTags retrieves all tags for an MCP server
func (s *TagService) GetMCPServerTags(ctx context.Context, mcpServerID uuid.UUID) ([]*domain.Tag, error) <span class="cov0" title="0">{
        tags, err := s.tagRepo.GetMCPServerTags(ctx, mcpServerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get mcp server tags: %w", err)
        }</span>
        <span class="cov0" title="0">return tags, nil</span>
}

// SuggestTagsForAgent suggests tags based on agent metadata
// TODO: Implement smart suggestions when capabilities tracking is added
func (s *TagService) SuggestTagsForAgent(ctx context.Context, agentID uuid.UUID) ([]*domain.Tag, error) <span class="cov0" title="0">{
        _, err := s.agentRepo.GetByID(agentID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("agent not found: %w", err)
        }</span>

        // Return empty suggestions for now
        // Future: Analyze agent type, version, metadata for smart suggestions
        <span class="cov0" title="0">return []*domain.Tag{}, nil</span>
}

// SuggestTagsForMCPServer suggests tags based on MCP server metadata
// TODO: Implement smart suggestions when capabilities tracking is added
func (s *TagService) SuggestTagsForMCPServer(ctx context.Context, mcpServerID uuid.UUID) ([]*domain.Tag, error) <span class="cov0" title="0">{
        _, err := s.mcpRepo.GetByID(mcpServerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("mcp server not found: %w", err)
        }</span>

        // Return empty suggestions for now
        // Future: Analyze MCP server type, version, metadata for smart suggestions
        <span class="cov0" title="0">return []*domain.Tag{}, nil</span>
}

// GetPopularTags retrieves the most popular tags by usage count
func (s *TagService) GetPopularTags(ctx context.Context, orgID uuid.UUID, limit int) ([]*domain.Tag, error) <span class="cov0" title="0">{
        tags, err := s.tagRepo.GetPopularTags(ctx, orgID, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get popular tags: %w", err)
        }</span>
        <span class="cov0" title="0">return tags, nil</span>
}

// SearchTags searches for tags by query string (case-insensitive)
func (s *TagService) SearchTags(ctx context.Context, orgID uuid.UUID, query string, categoryFilter string) ([]*domain.Tag, error) <span class="cov0" title="0">{
        var category *domain.TagCategory
        if categoryFilter != "" </span><span class="cov0" title="0">{
                cat := domain.TagCategory(categoryFilter)
                category = &amp;cat
        }</span>

        <span class="cov0" title="0">tags, err := s.tagRepo.SearchTags(ctx, orgID, query, category)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to search tags: %w", err)
        }</span>
        <span class="cov0" title="0">return tags, nil</span>
}

// validateTagInput validates tag creation input
func (s *TagService) validateTagInput(input CreateTagInput) error <span class="cov0" title="0">{
        if input.Key == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("tag key is required")
        }</span>
        <span class="cov0" title="0">if input.Value == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("tag value is required")
        }</span>
        <span class="cov0" title="0">if len(input.Key) &gt; 100 </span><span class="cov0" title="0">{
                return fmt.Errorf("tag key must be 100 characters or less")
        }</span>
        <span class="cov0" title="0">if len(input.Value) &gt; 255 </span><span class="cov0" title="0">{
                return fmt.Errorf("tag value must be 255 characters or less")
        }</span>

        // Validate category
        <span class="cov0" title="0">validCategories := map[domain.TagCategory]bool{
                domain.TagCategoryResourceType:       true,
                domain.TagCategoryEnvironment:        true,
                domain.TagCategoryAgentType:          true,
                domain.TagCategoryDataClassification: true,
                domain.TagCategoryCustom:             true,
        }
        if !validCategories[input.Category] </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid tag category: %s", input.Category)
        }</span>

        // Validate color format (hex color)
        <span class="cov0" title="0">if input.Color != "" </span><span class="cov0" title="0">{
                if !strings.HasPrefix(input.Color, "#") || len(input.Color) != 7 </span><span class="cov0" title="0">{
                        return fmt.Errorf("color must be a valid hex color (e.g., #3B82F6)")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package application

import (
        "context"
        "crypto/x509"
        "encoding/pem"
        "math"
        "net/http"
        "net/url"
        "strings"
        "time"

        "github.com/google/uuid"
        "github.com/opena2a/identity/backend/internal/domain"
)

// TrustCalculator implements domain.TrustScoreCalculator
type TrustCalculator struct {
        trustScoreRepo   domain.TrustScoreRepository
        apiKeyRepo       domain.APIKeyRepository
        auditRepo        domain.AuditLogRepository
        capabilityRepo   domain.CapabilityRepository
}

// NewTrustCalculator creates a new trust calculator
func NewTrustCalculator(
        trustScoreRepo domain.TrustScoreRepository,
        apiKeyRepo domain.APIKeyRepository,
        auditRepo domain.AuditLogRepository,
        capabilityRepo domain.CapabilityRepository,
) *TrustCalculator <span class="cov8" title="1">{
        return &amp;TrustCalculator{
                trustScoreRepo:   trustScoreRepo,
                apiKeyRepo:       apiKeyRepo,
                auditRepo:        auditRepo,
                capabilityRepo:   capabilityRepo,
        }
}</span>

// Calculate calculates trust score for an agent
func (c *TrustCalculator) Calculate(agent *domain.Agent) (*domain.TrustScore, error) <span class="cov8" title="1">{
        factors, err := c.CalculateFactors(agent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Weighted average of factors (9 factors totaling 100%)
        <span class="cov8" title="1">weights := map[string]float64{
                "verification":    0.18, // Identity verification (reduced from 0.20)
                "certificate":     0.12, // Certificate validity (reduced from 0.15)
                "repository":      0.12, // Repository quality (reduced from 0.15)
                "documentation":   0.08, // Documentation score (reduced from 0.10)
                "community":       0.08, // Community trust (reduced from 0.10)
                "security":        0.12, // Security audit (reduced from 0.15)
                "updates":         0.08, // Update frequency (reduced from 0.10)
                "age":             0.05, // Agent age (unchanged)
                "capability_risk": 0.17, // Capability risk (NEW - high importance)
        }

        score := factors.VerificationStatus*weights["verification"] +
                factors.CertificateValidity*weights["certificate"] +
                factors.RepositoryQuality*weights["repository"] +
                factors.DocumentationScore*weights["documentation"] +
                factors.CommunityTrust*weights["community"] +
                factors.SecurityAudit*weights["security"] +
                factors.UpdateFrequency*weights["updates"] +
                factors.AgeScore*weights["age"] +
                factors.CapabilityRisk*weights["capability_risk"]

        // Calculate confidence based on available data
        confidence := c.calculateConfidence(agent, factors)

        return &amp;domain.TrustScore{
                ID:             uuid.New(),
                AgentID:        agent.ID,
                Score:          score,
                Factors:        *factors,
                Confidence:     confidence,
                LastCalculated: time.Now(),
                CreatedAt:      time.Now(),
        }, nil</span>
}

// CalculateFactors calculates individual trust factors
func (c *TrustCalculator) CalculateFactors(agent *domain.Agent) (*domain.TrustScoreFactors, error) <span class="cov8" title="1">{
        factors := &amp;domain.TrustScoreFactors{}

        // 1. Verification Status (0-1)
        factors.VerificationStatus = c.calculateVerificationStatus(agent)

        // 2. Certificate Validity (0-1)
        factors.CertificateValidity = c.calculateCertificateValidity(agent)

        // 3. Repository Quality (0-1)
        factors.RepositoryQuality = c.calculateRepositoryQuality(agent)

        // 4. Documentation Score (0-1)
        factors.DocumentationScore = c.calculateDocumentationScore(agent)

        // 5. Community Trust (0-1)
        factors.CommunityTrust = c.calculateCommunityTrust(agent)

        // 6. Security Audit (0-1)
        factors.SecurityAudit = c.calculateSecurityAudit(agent)

        // 7. Update Frequency (0-1)
        factors.UpdateFrequency = c.calculateUpdateFrequency(agent)

        // 8. Age Score (0-1)
        factors.AgeScore = c.calculateAgeScore(agent)

        // 9. Capability Risk (0-1, where 1 = low risk, 0 = high risk)
        factors.CapabilityRisk = c.calculateCapabilityRisk(agent)

        return factors, nil
}</span>

func (c *TrustCalculator) calculateVerificationStatus(agent *domain.Agent) float64 <span class="cov8" title="1">{
        switch agent.Status </span>{
        case domain.AgentStatusVerified:<span class="cov8" title="1">
                return 1.0</span>
        case domain.AgentStatusPending:<span class="cov8" title="1">
                return 0.3</span>
        case domain.AgentStatusSuspended:<span class="cov8" title="1">
                return 0.1</span>
        case domain.AgentStatusRevoked:<span class="cov8" title="1">
                return 0.0</span>
        default:<span class="cov8" title="1">
                return 0.3</span>
        }
}

func (c *TrustCalculator) calculateCertificateValidity(agent *domain.Agent) float64 <span class="cov8" title="1">{
        // Check if certificate URL is provided
        if agent.CertificateURL == "" </span><span class="cov8" title="1">{
                return 0.0
        }</span>

        // Check if public key is provided
        <span class="cov8" title="1">if agent.PublicKey == nil || *agent.PublicKey == "" </span><span class="cov8" title="1">{
                return 0.3
        }</span>

        // Try to parse the public key
        <span class="cov8" title="1">block, _ := pem.Decode([]byte(*agent.PublicKey))
        if block == nil </span><span class="cov8" title="1">{
                return 0.3
        }</span>

        // Try to parse as X.509 certificate
        <span class="cov8" title="1">cert, err := x509.ParseCertificate(block.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return 0.5
        }</span>

        // Check if certificate is expired
        <span class="cov8" title="1">now := time.Now()
        if now.Before(cert.NotBefore) || now.After(cert.NotAfter) </span><span class="cov8" title="1">{
                return 0.2
        }</span>

        // Certificate is valid
        <span class="cov8" title="1">return 1.0</span>
}

func (c *TrustCalculator) calculateRepositoryQuality(agent *domain.Agent) float64 <span class="cov8" title="1">{
        if agent.RepositoryURL == "" </span><span class="cov8" title="1">{
                return 0.0
        }</span>

        // Check if URL is valid
        <span class="cov8" title="1">parsedURL, err := url.Parse(agent.RepositoryURL)
        if err != nil </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov8" title="1">score := 0.0

        // Check if it's a known repository hosting service
        host := strings.ToLower(parsedURL.Host)
        if strings.Contains(host, "github.com") ||
                strings.Contains(host, "gitlab.com") ||
                strings.Contains(host, "bitbucket.org") </span><span class="cov8" title="1">{
                score += 0.5
        }</span>

        // Check if URL is accessible
        <span class="cov8" title="1">resp, err := http.Head(agent.RepositoryURL)
        if err == nil &amp;&amp; resp.StatusCode == 200 </span><span class="cov0" title="0">{
                score += 0.5
        }</span>

        <span class="cov8" title="1">return math.Min(score, 1.0)</span>
}

func (c *TrustCalculator) calculateDocumentationScore(agent *domain.Agent) float64 <span class="cov8" title="1">{
        score := 0.0

        // Has description
        if agent.Description != "" &amp;&amp; len(agent.Description) &gt; 50 </span><span class="cov8" title="1">{
                score += 0.3
        }</span>

        // Has documentation URL
        <span class="cov8" title="1">if agent.DocumentationURL != "" </span><span class="cov8" title="1">{
                score += 0.3

                // Check if documentation is accessible
                resp, err := http.Head(agent.DocumentationURL)
                if err == nil &amp;&amp; resp.StatusCode == 200 </span><span class="cov0" title="0">{
                        score += 0.4
                }</span>
        }

        <span class="cov8" title="1">return math.Min(score, 1.0)</span>
}

func (c *TrustCalculator) calculateCommunityTrust(agent *domain.Agent) float64 <span class="cov8" title="1">{
        // This would integrate with external reputation systems
        // For MVP, return a baseline score
        return 0.5
}</span>

func (c *TrustCalculator) calculateSecurityAudit(agent *domain.Agent) float64 <span class="cov8" title="1">{
        // This would check for security audit reports
        // For MVP, return a baseline score
        return 0.5
}</span>

func (c *TrustCalculator) calculateUpdateFrequency(agent *domain.Agent) float64 <span class="cov8" title="1">{
        // Check how recently the agent was updated
        daysSinceUpdate := time.Since(agent.UpdatedAt).Hours() / 24

        if daysSinceUpdate &lt; 30 </span><span class="cov8" title="1">{
                return 1.0
        }</span> else<span class="cov8" title="1"> if daysSinceUpdate &lt; 90 </span><span class="cov8" title="1">{
                return 0.7
        }</span> else<span class="cov8" title="1"> if daysSinceUpdate &lt; 180 </span><span class="cov8" title="1">{
                return 0.5
        }</span> else<span class="cov8" title="1"> if daysSinceUpdate &lt; 365 </span><span class="cov8" title="1">{
                return 0.3
        }</span>
        <span class="cov8" title="1">return 0.1</span>
}

func (c *TrustCalculator) calculateAgeScore(agent *domain.Agent) float64 <span class="cov8" title="1">{
        // Older agents are more established
        daysSinceCreation := time.Since(agent.CreatedAt).Hours() / 24

        if daysSinceCreation &lt; 7 </span><span class="cov8" title="1">{
                return 0.2
        }</span> else<span class="cov8" title="1"> if daysSinceCreation &lt; 30 </span><span class="cov8" title="1">{
                return 0.4
        }</span> else<span class="cov8" title="1"> if daysSinceCreation &lt; 90 </span><span class="cov8" title="1">{
                return 0.6
        }</span> else<span class="cov8" title="1"> if daysSinceCreation &lt; 180 </span><span class="cov8" title="1">{
                return 0.8
        }</span>
        <span class="cov8" title="1">return 1.0</span>
}

func (c *TrustCalculator) calculateCapabilityRisk(agent *domain.Agent) float64 <span class="cov8" title="1">{
        // Start with baseline score (no capabilities detected = neutral risk)
        score := 0.7 // Neutral baseline

        // Get active capabilities for the agent
        capabilities, err := c.capabilityRepo.GetActiveCapabilitiesByAgentID(agent.ID)
        if err != nil </span><span class="cov8" title="1">{
                // On error, check violations only and return
                violations, _, err := c.capabilityRepo.GetViolationsByAgentID(agent.ID, 100, 0)
                if err == nil &amp;&amp; len(violations) &gt; 0 </span><span class="cov0" title="0">{
                        score = c.applyViolationPenalties(score, violations)
                }</span>
                <span class="cov8" title="1">return score</span>
        }

        // Calculate risk based on capabilities (if any)
        <span class="cov8" title="1">if len(capabilities) &gt; 0 </span><span class="cov8" title="1">{
                // Define high-risk capability types
                highRiskCapabilities := map[string]float64{
                        domain.CapabilityFileDelete:      -0.15, // File deletion is high risk
                        domain.CapabilitySystemAdmin:     -0.20, // System admin is very high risk
                        domain.CapabilityUserImpersonate: -0.20, // Impersonation is very high risk
                        domain.CapabilityDataExport:      -0.10, // Data export is moderate risk
                }

                mediumRiskCapabilities := map[string]float64{
                        domain.CapabilityFileWrite:   -0.08,
                        domain.CapabilityDBWrite:     -0.08,
                        domain.CapabilityAPICall:     -0.05,
                }

                lowRiskCapabilities := map[string]float64{
                        domain.CapabilityFileRead:    -0.03,
                        domain.CapabilityDBQuery:     -0.03,
                        domain.CapabilityMCPToolUse:  -0.02,
                }

                // Calculate risk based on capabilities
                for _, cap := range capabilities </span><span class="cov8" title="1">{
                        // Check high-risk capabilities
                        if penalty, exists := highRiskCapabilities[cap.CapabilityType]; exists </span><span class="cov8" title="1">{
                                score += penalty
                        }</span> else<span class="cov0" title="0"> if penalty, exists := mediumRiskCapabilities[cap.CapabilityType]; exists </span><span class="cov0" title="0">{
                                score += penalty
                        }</span> else<span class="cov0" title="0"> if penalty, exists := lowRiskCapabilities[cap.CapabilityType]; exists </span><span class="cov0" title="0">{
                                score += penalty
                        }</span>
                }
        }

        // Check for violations (independent of capabilities)
        <span class="cov8" title="1">violations, _, err := c.capabilityRepo.GetViolationsByAgentID(agent.ID, 100, 0)
        if err == nil &amp;&amp; len(violations) &gt; 0 </span><span class="cov8" title="1">{
                score = c.applyViolationPenalties(score, violations)
        }</span>

        <span class="cov8" title="1">return score</span>
}

// applyViolationPenalties applies trust score penalties based on violations
func (c *TrustCalculator) applyViolationPenalties(score float64, violations []*domain.CapabilityViolation) float64 <span class="cov8" title="1">{
        // Recent violations significantly impact trust
        recentViolations := 0
        thirtyDaysAgo := time.Now().AddDate(0, 0, -30)

        for _, violation := range violations </span><span class="cov8" title="1">{
                if violation.CreatedAt.After(thirtyDaysAgo) </span><span class="cov8" title="1">{
                        recentViolations++

                        // Additional penalty based on violation severity
                        switch violation.Severity </span>{
                        case domain.ViolationSeverityCritical:<span class="cov8" title="1">
                                score -= 0.15</span>
                        case domain.ViolationSeverityHigh:<span class="cov0" title="0">
                                score -= 0.10</span>
                        case domain.ViolationSeverityMedium:<span class="cov0" title="0">
                                score -= 0.05</span>
                        case domain.ViolationSeverityLow:<span class="cov0" title="0">
                                score -= 0.02</span>
                        }
                }
        }

        // Cap violations penalty
        <span class="cov8" title="1">if recentViolations &gt; 10 </span><span class="cov8" title="1">{
                score -= 0.20 // Significant violation history
        }</span> else<span class="cov0" title="0"> if recentViolations &gt; 5 </span><span class="cov0" title="0">{
                score -= 0.10
        }</span>

        // Ensure score stays within bounds [0, 1]
        <span class="cov8" title="1">if score &lt; 0 </span><span class="cov8" title="1">{
                score = 0
        }</span>
        <span class="cov8" title="1">if score &gt; 1 </span><span class="cov0" title="0">{
                score = 1
        }</span>

        <span class="cov8" title="1">return score</span>
}

func (c *TrustCalculator) calculateConfidence(agent *domain.Agent, factors *domain.TrustScoreFactors) float64 <span class="cov8" title="1">{
        // Calculate confidence based on available data
        dataPoints := 0.0
        total := 0.0

        if agent.Status != "" </span><span class="cov8" title="1">{
                dataPoints++
        }</span>
        <span class="cov8" title="1">if agent.PublicKey != nil &amp;&amp; *agent.PublicKey != "" </span><span class="cov8" title="1">{
                dataPoints++
        }</span>
        <span class="cov8" title="1">if agent.CertificateURL != "" </span><span class="cov8" title="1">{
                dataPoints++
        }</span>
        <span class="cov8" title="1">if agent.RepositoryURL != "" </span><span class="cov8" title="1">{
                dataPoints++
        }</span>
        <span class="cov8" title="1">if agent.DocumentationURL != "" </span><span class="cov8" title="1">{
                dataPoints++
        }</span>
        <span class="cov8" title="1">if agent.Description != "" </span><span class="cov8" title="1">{
                dataPoints++
        }</span>
        <span class="cov8" title="1">if agent.Version != "" </span><span class="cov8" title="1">{
                dataPoints++
        }</span>

        <span class="cov8" title="1">total = 7.0 // Total possible data points

        return dataPoints / total</span>
}

// CalculateTrustScore calculates and stores trust score for an agent
func (c *TrustCalculator) CalculateTrustScore(ctx context.Context, agentID uuid.UUID) (*domain.TrustScore, error) <span class="cov0" title="0">{
        // This would normally fetch the agent first
        // For MVP, we'll create a placeholder implementation
        // In production, would fetch agent and call Calculate()

        // For now, return a simple calculated score
        score := &amp;domain.TrustScore{
                ID:             uuid.New(),
                AgentID:        agentID,
                Score:          0.75,
                Confidence:     0.8,
                LastCalculated: time.Now(),
                CreatedAt:      time.Now(),
        }

        // Store the score
        if err := c.trustScoreRepo.Create(score); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return score, nil</span>
}

// GetLatestTrustScore retrieves the latest trust score for an agent
func (c *TrustCalculator) GetLatestTrustScore(ctx context.Context, agentID uuid.UUID) (*domain.TrustScore, error) <span class="cov0" title="0">{
        return c.trustScoreRepo.GetLatest(agentID)
}</span>

// GetTrustScoreHistory retrieves trust score history for an agent
func (c *TrustCalculator) GetTrustScoreHistory(ctx context.Context, agentID uuid.UUID, limit int) ([]*domain.TrustScore, error) <span class="cov0" title="0">{
        return c.trustScoreRepo.GetHistory(agentID, limit)
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package application

import (
        "context"
        "fmt"
        "time"

        "github.com/google/uuid"
        "github.com/opena2a/identity/backend/internal/domain"
)

// VerificationEventService handles verification event business logic
type VerificationEventService struct {
        eventRepo         domain.VerificationEventRepository
        agentRepo         domain.AgentRepository
        driftDetection    *DriftDetectionService
}

// NewVerificationEventService creates a new verification event service
func NewVerificationEventService(
        eventRepo domain.VerificationEventRepository,
        agentRepo domain.AgentRepository,
        driftDetection *DriftDetectionService,
) *VerificationEventService <span class="cov0" title="0">{
        return &amp;VerificationEventService{
                eventRepo:      eventRepo,
                agentRepo:      agentRepo,
                driftDetection: driftDetection,
        }
}</span>

// LogVerificationEvent creates a new verification event (for automatic logging)
func (s *VerificationEventService) LogVerificationEvent(
        ctx context.Context,
        orgID uuid.UUID,
        agentID uuid.UUID,
        protocol domain.VerificationProtocol,
        verificationType domain.VerificationType,
        status domain.VerificationEventStatus,
        durationMs int,
        initiatorType domain.InitiatorType,
        initiatorID *uuid.UUID,
        metadata map[string]interface{},
) (*domain.VerificationEvent, error) <span class="cov0" title="0">{
        // Get agent details
        agent, err := s.agentRepo.GetByID(agentID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("agent not found: %w", err)
        }</span>

        <span class="cov0" title="0">now := time.Now()
        agentIDPtr := &amp;agentID
        agentNamePtr := &amp;agent.DisplayName

        event := &amp;domain.VerificationEvent{
                OrganizationID:   orgID,
                AgentID:          agentIDPtr,
                AgentName:        agentNamePtr,
                Protocol:         protocol,
                VerificationType: verificationType,
                Status:           status,
                Confidence:       calculateConfidence(status, agent.TrustScore),
                TrustScore:       agent.TrustScore,
                DurationMs:       durationMs,
                InitiatorType:    initiatorType,
                InitiatorID:      initiatorID,
                StartedAt:        now.Add(-time.Duration(durationMs) * time.Millisecond),
                CompletedAt:      &amp;now,
                CreatedAt:        now,
                Metadata:         metadata,
        }

        if err := s.eventRepo.Create(event); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create verification event: %w", err)
        }</span>

        <span class="cov0" title="0">return event, nil</span>
}

// CreateVerificationEvent creates a manual verification event with full details
func (s *VerificationEventService) CreateVerificationEvent(
        ctx context.Context,
        req *CreateVerificationEventRequest,
) (*domain.VerificationEvent, error) <span class="cov0" title="0">{
        // Validate agent exists
        agent, err := s.agentRepo.GetByID(req.AgentID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("agent not found: %w", err)
        }</span>

        <span class="cov0" title="0">agentIDPtr := &amp;req.AgentID
        agentNamePtr := &amp;agent.DisplayName

        event := &amp;domain.VerificationEvent{
                OrganizationID:   req.OrganizationID,
                AgentID:          agentIDPtr,
                AgentName:        agentNamePtr,
                Protocol:         req.Protocol,
                VerificationType: req.VerificationType,
                Status:           req.Status,
                Result:           req.Result,
                Signature:        req.Signature,
                MessageHash:      req.MessageHash,
                Nonce:            req.Nonce,
                PublicKey:        req.PublicKey,
                Confidence:       req.Confidence,
                TrustScore:       agent.TrustScore,
                DurationMs:       req.DurationMs,
                ErrorCode:        req.ErrorCode,
                ErrorReason:      req.ErrorReason,
                InitiatorType:    req.InitiatorType,
                InitiatorID:      req.InitiatorID,
                InitiatorName:    req.InitiatorName,
                InitiatorIP:      req.InitiatorIP,
                Action:           req.Action,
                ResourceType:     req.ResourceType,
                ResourceID:       req.ResourceID,
                Location:         req.Location,
                StartedAt:        req.StartedAt,
                CompletedAt:      req.CompletedAt,
                Details:          req.Details,
                Metadata:         req.Metadata,

                // Store runtime configuration for drift tracking
                CurrentMCPServers:   req.CurrentMCPServers,
                CurrentCapabilities: req.CurrentCapabilities,
        }

        // Perform drift detection if runtime configuration provided
        if len(req.CurrentMCPServers) &gt; 0 || len(req.CurrentCapabilities) &gt; 0 </span><span class="cov0" title="0">{
                driftResult, err := s.driftDetection.DetectDrift(
                        req.AgentID,
                        req.CurrentMCPServers,
                        req.CurrentCapabilities,
                )

                if err != nil </span><span class="cov0" title="0">{
                        // Log error but don't fail the verification event creation
                        fmt.Printf("Drift detection failed: %v\n", err)
                }</span> else<span class="cov0" title="0"> if driftResult != nil </span><span class="cov0" title="0">{
                        // Store drift detection results in the event
                        event.DriftDetected = driftResult.DriftDetected
                        event.MCPServerDrift = driftResult.MCPServerDrift
                        event.CapabilityDrift = driftResult.CapabilityDrift
                }</span>
        }

        <span class="cov0" title="0">if err := s.eventRepo.Create(event); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create verification event: %w", err)
        }</span>

        <span class="cov0" title="0">return event, nil</span>
}

// GetVerificationEvent retrieves a verification event by ID
func (s *VerificationEventService) GetVerificationEvent(ctx context.Context, id uuid.UUID) (*domain.VerificationEvent, error) <span class="cov0" title="0">{
        return s.eventRepo.GetByID(id)
}</span>

// ListVerificationEvents retrieves verification events for an organization
func (s *VerificationEventService) ListVerificationEvents(
        ctx context.Context,
        orgID uuid.UUID,
        limit, offset int,
) ([]*domain.VerificationEvent, int, error) <span class="cov0" title="0">{
        return s.eventRepo.GetByOrganization(orgID, limit, offset)
}</span>

// ListAgentVerificationEvents retrieves verification events for a specific agent
func (s *VerificationEventService) ListAgentVerificationEvents(
        ctx context.Context,
        agentID uuid.UUID,
        limit, offset int,
) ([]*domain.VerificationEvent, int, error) <span class="cov0" title="0">{
        return s.eventRepo.GetByAgent(agentID, limit, offset)
}</span>

// ListMCPVerificationEvents retrieves verification events for a specific MCP server
func (s *VerificationEventService) ListMCPVerificationEvents(
        ctx context.Context,
        mcpServerID uuid.UUID,
        limit, offset int,
) ([]*domain.VerificationEvent, int, error) <span class="cov0" title="0">{
        return s.eventRepo.GetByMCPServer(mcpServerID, limit, offset)
}</span>

// GetRecentEvents retrieves recent verification events (for real-time monitoring)
func (s *VerificationEventService) GetRecentEvents(ctx context.Context, orgID uuid.UUID, minutes int) ([]*domain.VerificationEvent, error) <span class="cov0" title="0">{
        return s.eventRepo.GetRecentEvents(orgID, minutes)
}</span>

// GetStatistics calculates verification statistics for a time range
func (s *VerificationEventService) GetStatistics(
        ctx context.Context,
        orgID uuid.UUID,
        startTime, endTime time.Time,
) (*domain.VerificationStatistics, error) <span class="cov0" title="0">{
        return s.eventRepo.GetStatistics(orgID, startTime, endTime)
}</span>

// GetLast24HoursStatistics calculates statistics for the last 24 hours
func (s *VerificationEventService) GetLast24HoursStatistics(ctx context.Context, orgID uuid.UUID) (*domain.VerificationStatistics, error) <span class="cov0" title="0">{
        endTime := time.Now()
        startTime := endTime.Add(-24 * time.Hour)
        return s.eventRepo.GetStatistics(orgID, startTime, endTime)
}</span>

// UpdateVerificationResult updates the result of a verification event
func (s *VerificationEventService) UpdateVerificationResult(
        ctx context.Context,
        id uuid.UUID,
        result domain.VerificationResult,
        reason *string,
        metadata map[string]interface{},
) error <span class="cov0" title="0">{
        return s.eventRepo.UpdateResult(id, result, reason, metadata)
}</span>

// DeleteVerificationEvent deletes a verification event
func (s *VerificationEventService) DeleteVerificationEvent(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        return s.eventRepo.Delete(id)
}</span>

// CreateVerificationEventRequest represents a request to create a verification event
type CreateVerificationEventRequest struct {
        OrganizationID   uuid.UUID
        AgentID          uuid.UUID
        Protocol         domain.VerificationProtocol
        VerificationType domain.VerificationType
        Status           domain.VerificationEventStatus
        Result           *domain.VerificationResult
        Signature        *string
        MessageHash      *string
        Nonce            *string
        PublicKey        *string
        Confidence       float64
        DurationMs       int
        ErrorCode        *string
        ErrorReason      *string
        InitiatorType    domain.InitiatorType
        InitiatorID      *uuid.UUID
        InitiatorName    *string
        InitiatorIP      *string
        Action           *string
        ResourceType     *string
        ResourceID       *string
        Location         *string
        StartedAt        time.Time
        CompletedAt      *time.Time
        Details          *string
        Metadata         map[string]interface{}

        // Configuration Drift Detection (WHO and WHAT)
        CurrentMCPServers    []string // Runtime: MCP servers being communicated with
        CurrentCapabilities  []string // Runtime: Capabilities being used
}

// calculateConfidence calculates confidence based on status and trust score
func calculateConfidence(status domain.VerificationEventStatus, trustScore float64) float64 <span class="cov0" title="0">{
        baseConfidence := trustScore / 100.0 // Convert 0-100 to 0-1

        switch status </span>{
        case domain.VerificationEventStatusSuccess:<span class="cov0" title="0">
                return min(baseConfidence+0.1, 1.0)</span> // Boost by 10%
        case domain.VerificationEventStatusFailed:<span class="cov0" title="0">
                return max(baseConfidence-0.2, 0.0)</span> // Reduce by 20%
        case domain.VerificationEventStatusTimeout:<span class="cov0" title="0">
                return max(baseConfidence-0.3, 0.0)</span> // Reduce by 30%
        case domain.VerificationEventStatusPending:<span class="cov0" title="0">
                return baseConfidence</span>
        default:<span class="cov0" title="0">
                return baseConfidence</span>
        }
}

func min(a, b float64) float64 <span class="cov0" title="0">{
        if a &lt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}

func max(a, b float64) float64 <span class="cov0" title="0">{
        if a &gt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package application

import (
        "bytes"
        "context"
        "crypto/hmac"
        "crypto/rand"
        "crypto/sha256"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "time"

        "github.com/google/uuid"
        "github.com/opena2a/identity/backend/internal/domain"
        "github.com/opena2a/identity/backend/internal/infrastructure/repository"
)

type WebhookService struct {
        webhookRepo *repository.WebhookRepository
}

func NewWebhookService(webhookRepo *repository.WebhookRepository) *WebhookService <span class="cov0" title="0">{
        return &amp;WebhookService{
                webhookRepo: webhookRepo,
        }
}</span>

// CreateWebhookRequest represents the request to create a webhook
type CreateWebhookRequest struct {
        Name   string                 `json:"name" validate:"required"`
        URL    string                 `json:"url" validate:"required,url"`
        Events []domain.WebhookEvent  `json:"events" validate:"required"`
}

// CreateWebhook creates a new webhook subscription
func (s *WebhookService) CreateWebhook(ctx context.Context, req *CreateWebhookRequest, orgID, userID uuid.UUID) (*domain.Webhook, error) <span class="cov0" title="0">{
        // Generate secret for webhook signature
        secret, err := generateSecret()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">webhook := &amp;domain.Webhook{
                ID:             uuid.New(),
                OrganizationID: orgID,
                Name:           req.Name,
                URL:            req.URL,
                Events:         req.Events,
                Secret:         secret,
                IsActive:       true,
                FailureCount:   0,
                CreatedBy:      userID,
                CreatedAt:      time.Now().UTC(),
                UpdatedAt:      time.Now().UTC(),
        }

        if err := s.webhookRepo.Create(webhook); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return webhook, nil</span>
}

// ListWebhooks lists all webhooks for an organization
func (s *WebhookService) ListWebhooks(ctx context.Context, orgID uuid.UUID) ([]*domain.Webhook, error) <span class="cov0" title="0">{
        return s.webhookRepo.GetByOrganization(orgID)
}</span>

// GetWebhook retrieves a webhook by ID
func (s *WebhookService) GetWebhook(ctx context.Context, id uuid.UUID) (*domain.Webhook, error) <span class="cov0" title="0">{
        return s.webhookRepo.GetByID(id)
}</span>

// DeleteWebhook deletes a webhook
func (s *WebhookService) DeleteWebhook(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        return s.webhookRepo.Delete(id)
}</span>

// TestWebhook sends a test payload to a webhook
func (s *WebhookService) TestWebhook(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        webhook, err := s.webhookRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create test payload
        <span class="cov0" title="0">payload := map[string]interface{}{
                "event":      "webhook.test",
                "webhook_id": webhook.ID.String(),
                "timestamp":  time.Now().UTC(),
                "data": map[string]string{
                        "message": "This is a test webhook delivery",
                },
        }

        return s.sendWebhook(webhook, "webhook.test", payload)</span>
}

// sendWebhook sends a webhook payload
func (s *WebhookService) sendWebhook(webhook *domain.Webhook, event string, payload interface{}) error <span class="cov0" title="0">{
        jsonData, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create signature
        <span class="cov0" title="0">signature := createSignature(jsonData, webhook.Secret)

        // Send HTTP request
        req, err := http.NewRequest("POST", webhook.URL, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("X-Webhook-Signature", signature)
        req.Header.Set("X-Webhook-Event", event)

        client := &amp;http.Client{Timeout: 10 * time.Second}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        // Read response
        body, _ := io.ReadAll(resp.Body)

        // Record delivery
        delivery := &amp;domain.WebhookDelivery{
                ID:           uuid.New(),
                WebhookID:    webhook.ID,
                Event:        domain.WebhookEvent(event),
                Payload:      string(jsonData),
                StatusCode:   resp.StatusCode,
                ResponseBody: string(body),
                Success:      resp.StatusCode &gt;= 200 &amp;&amp; resp.StatusCode &lt; 300,
                AttemptCount: 1,
                CreatedAt:    time.Now().UTC(),
        }

        s.webhookRepo.RecordDelivery(delivery)

        if !delivery.Success </span><span class="cov0" title="0">{
                return fmt.Errorf("webhook delivery failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Helper functions

func generateSecret() (string, error) <span class="cov0" title="0">{
        b := make([]byte, 32)
        _, err := rand.Read(b)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return hex.EncodeToString(b), nil</span>
}

func createSignature(payload []byte, secret string) string <span class="cov0" title="0">{
        mac := hmac.New(sha256.New, []byte(secret))
        mac.Write(payload)
        return hex.EncodeToString(mac.Sum(nil))
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
